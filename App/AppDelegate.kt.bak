package com.love2loveapp

import android.app.Application
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import android.util.Log
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.ProcessLifecycleOwner
import com.google.firebase.FirebaseApp
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.messaging.FirebaseMessaging
import com.google.firebase.appcheck.FirebaseAppCheck
import com.google.firebase.appcheck.debug.DebugAppCheckProviderFactory
import com.google.firebase.appcheck.playintegrity.PlayIntegrityAppCheckProviderFactory
import com.revenuecat.purchases.LogLevel
import com.revenuecat.purchases.Purchases
import com.revenuecat.purchases.PurchasesConfiguration
import com.love2loveapp.config.AppCheckConfig
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow

class AppDelegate : Application() {

    companion object {
        private const val TAG = "AppDelegate"
        const val NOTIFICATION_CHANNEL_ID = "default_channel"
    }

    private lateinit var auth: FirebaseAuth
    val currentUser = MutableStateFlow<FirebaseAuth?>(null)
    private val _authEvents = MutableSharedFlow<Boolean>(replay = 0)
    val authEvents = _authEvents.asSharedFlow()

    override fun onCreate() {
        super.onCreate()
        Log.i(TAG, "ðŸ”¥ AppDelegate: Application start")

        // ðŸ›¡ï¸ IMPORTANT: Initialiser AppCheckConfig avec le contexte
        AppCheckConfig.appContext = applicationContext
        
        // ðŸ›¡ï¸ Test du token debug - AppCheckConfig gÃ¨re ses propres logs dÃ©taillÃ©s
        val tokenStatus = if (AppCheckConfig.isDebugTokenConfigured) "âœ… CONFIGURÃ‰" else "âŒ NON CONFIGURÃ‰"
        Log.i(TAG, "ðŸ”‘ AppCheck Debug Token: $tokenStatus")

        configureFirebase()
        configureAppCheck()
        configureRevenueCat()
        configureNotifications()

        // Observer le cycle de vie global (Ã©quivalent applicationDidBecomeActive iOS)
        ProcessLifecycleOwner.get().lifecycle.addObserver(object : DefaultLifecycleObserver {
            override fun onStart(owner: LifecycleOwner) {
                Log.i(TAG, "ðŸŒ± AppDelegate: Application in foreground, clearing all notifications")
                val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                manager.cancelAll()
            }
        })
    }

    /**
     * Initialiser Firebase (Auth + Messaging)
     */
    private fun configureFirebase() {
        FirebaseApp.initializeApp(this)
        auth = FirebaseAuth.getInstance()

        // Listener Auth global
        auth.addAuthStateListener { firebaseAuth ->
            val user = firebaseAuth.currentUser
            if (user != null) {
                Log.i(TAG, "âœ… Firebase session restored: ${user.uid}")
                _authEvents.tryEmit(true)
                
                // ðŸ”„ CENTRALIZATION: Flush any stashed FCM token when user logs in
                MyFirebaseMessagingService.flushStashedTokenIfAny(this@AppDelegate)
            } else {
                Log.i(TAG, "â„¹ï¸ No authenticated user")
                _authEvents.tryEmit(false)
            }
        }

        // RÃ©cupÃ©rer le token FCM
        FirebaseMessaging.getInstance().token.addOnCompleteListener { task ->
            if (!task.isSuccessful) {
                Log.w(TAG, "âŒ Failed to get FCM token", task.exception)
                return@addOnCompleteListener
            }
            val token = task.result
            Log.i(TAG, "ðŸ“² FCM Token: $token")
            // TODO: envoyer au backend Firestore (users/{id}.fcmToken)
        }
    }

    /**
     * Configuration App Check (Play Integrity en prod, Debug en dev)
     */
    private fun configureAppCheck() {
        val appCheck = FirebaseAppCheck.getInstance()
        
        if (BuildConfig.DEBUG) {
            // En debug: utiliser Debug Provider si token configurÃ©, sinon dÃ©sactiver
            if (AppCheckConfig.isDebugTokenConfigured) {
                Log.i(TAG, "ðŸ›¡ï¸ AppCheck: Configuration DEBUG dÃ©tectÃ©e")
                
                // ðŸ›¡ï¸ IMPORTANT: Configurer le debug token AVANT d'installer le provider
                AppCheckConfig.debugToken?.let { token ->
                    System.setProperty("firebase.appcheck.debug_token", token)
                    Log.i(TAG, "ðŸ”‘ Debug token configurÃ© dans System Properties")
                }
                
                appCheck.installAppCheckProviderFactory(DebugAppCheckProviderFactory.getInstance())
                Log.i(TAG, "ðŸ›¡ï¸ AppCheck DebugProvider installÃ© âœ…")
                Log.i(TAG, "ðŸ” Mode DEBUG - toutes les requÃªtes seront autorisÃ©es avec token valide")
            } else {
                Log.w(TAG, "ðŸ›¡ï¸ AppCheck: Aucun debug token â†’ DÃ‰SACTIVÃ‰ en mode debug")
                Log.w(TAG, "âš ï¸ App Check complÃ¨tement dÃ©sactivÃ© - aucune protection")
                // Ne pas installer de provider = App Check dÃ©sactivÃ©
            }
        } else {
            Log.i(TAG, "ðŸ›¡ï¸ AppCheck: Configuration PRODUCTION dÃ©tectÃ©e")
            appCheck.installAppCheckProviderFactory(PlayIntegrityAppCheckProviderFactory.getInstance())
            Log.i(TAG, "ðŸ›¡ï¸ AppCheck PlayIntegrity installÃ© âœ…")
            
            // ðŸŽ¯ IMPORTANT: Mode surveillance uniquement - aucun blocage
            Log.i(TAG, "ðŸ›¡ï¸ AppCheck: âš ï¸ Mode SURVEILLANCE activÃ© - aucun service ne sera bloquÃ©")
            Log.i(TAG, "ðŸ›¡ï¸ AppCheck: Les mÃ©triques seront collectÃ©es pendant 2-3 semaines")
            Log.i(TAG, "ðŸ›¡ï¸ AppCheck: Activation de l'enforcement sera faite manuellement plus tard")
        }
        
        // ðŸ“Š RÃ©capitulatif final
        val providerType = if (BuildConfig.DEBUG && AppCheckConfig.isDebugTokenConfigured) "DebugProvider" else if (!BuildConfig.DEBUG) "PlayIntegrityProvider" else "AUCUN"
        Log.i(TAG, "ðŸŽ¯ AppCheck configurÃ©: $providerType")
    }

    /**
     * Configuration RevenueCat
     */
    private fun configureRevenueCat() {
        Log.i(TAG, "ðŸ’° Configuring RevenueCat")
        Purchases.logLevel = LogLevel.INFO
        Purchases.configure(
            PurchasesConfiguration(this, BuildConfig.REVENUECAT_GOOGLE_API_KEY) // ðŸ”‘ clÃ© Android RevenueCat depuis BuildConfig
        )
        Log.i(TAG, "ðŸ’° RevenueCat configurÃ© avec clÃ© depuis BuildConfig (sÃ©curisÃ©)")
    }

    /**
     * Notifications Android
     */
    private fun configureNotifications() {
        Log.i(TAG, "ðŸ“£ Configuring notifications")
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                NOTIFICATION_CHANNEL_ID,
                "Couple Notifications",
                NotificationManager.IMPORTANCE_DEFAULT
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(channel)
        }
    }
}
