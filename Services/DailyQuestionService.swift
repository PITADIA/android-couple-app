import Foundation
import FirebaseFirestore
import FirebaseAuth
import FirebaseFunctions
import Combine
import RealmSwift
import UserNotifications

@MainActor
class DailyQuestionService: ObservableObject {
    static let shared = DailyQuestionService()
    
    @Published var currentQuestion: DailyQuestion?
    @Published var questionHistory: [DailyQuestion] = []
    @Published var isLoading: Bool = false
    @Published var isOptimizing: Bool = false  // Nouvel √©tat pour l'optimisation timezone
    @Published var allQuestionsExhausted: Bool = false
    @Published var currentSettings: DailyQuestionSettings?
    
    private var db = Firestore.firestore()
    private var functions = Functions.functions()
    private var questionListener: ListenerRegistration?
    private var responsesListener: ListenerRegistration? // NOUVEAU: Listener pour sous-collections
    private var settingsListener: ListenerRegistration?
    
    // CORRECTION: R√©f√©rence weak √† AppState pour √©viter les cycles de r√©f√©rence
    private weak var appState: AppState?
    
    private init() {
        // Les listeners seront configur√©s via configure(with:)
    }
    
    deinit {
        questionListener?.remove()
        responsesListener?.remove()
        settingsListener?.remove()
    }
    
    // MARK: - Configuration
    
    func configure(with appState: AppState) {
        self.appState = appState
        
        // üåç Sauvegarder la langue utilisateur pour les notifications localis√©es
        saveUserLanguageToFirebase()
        
        setupListeners()
    }
    
    // MARK: - Setup et Lifecycle
    
    private func setupListeners() {
        guard let currentUser = Auth.auth().currentUser,
              let appState = appState,
              let currentAppUser = appState.currentUser,
              let partnerId = currentAppUser.partnerId,
              !partnerId.isEmpty else {
            print("üî• DailyQuestionService: Pas d'utilisateur connect√© ou de couple configur√©")
            return
        }
        
        // CORRECTION: Cr√©er le coupleId comme dans le reste de l'app
        let coupleId = [currentUser.uid, partnerId].sorted().joined(separator: "_")
        print("üî• DailyQuestionService: √âcoute des questions pour couple: \(coupleId)")
            
        // √âcouter les settings
        setupSettingsListener(for: coupleId)
        
        // √âcouter les questions
        setupQuestionsListener(for: coupleId)
            }
            
    private func setupSettingsListener(for coupleId: String) {
        settingsListener?.remove()
        
        settingsListener = db.collection("dailyQuestionSettings")
            .document(coupleId)
            .addSnapshotListener { [weak self] snapshot, error in
                Task { @MainActor in
                    if let error = error {
                        print("‚ùå DailyQuestionService: Erreur settings - \(error)")
            return
        }
        
                    if let data = snapshot?.data() {
                        // üîß LOGS TIMEZONE D√âTAILL√âS POUR SETTINGS
                        let currentTime = Date()
                        let timeFormatter = DateFormatter()
                        timeFormatter.timeStyle = .long
                        timeFormatter.dateStyle = .short
                        
                        print("‚öôÔ∏è SETTINGS FIRESTORE RE√áUS √Ä: \(timeFormatter.string(from: currentTime))")
                        print("‚öôÔ∏è - Timestamp exact: \(currentTime)")
                        print("‚öôÔ∏è - Raw data: \(data)")
                        
                        do {
                            let oldCurrentDay = self?.currentSettings?.currentDay ?? 0
                            let settings = try self?.createSettingsFromFirestore(data, coupleId: coupleId)
                            self?.currentSettings = settings
                            
                            print("‚öôÔ∏è SETTINGS LISTENER UPDATE:")
                            print("‚öôÔ∏è - Ancien currentDay: \(oldCurrentDay)")
                            print("‚öôÔ∏è - Nouveau currentDay: \(settings?.currentDay ?? 0)")
                            print("‚öôÔ∏è - startDate: \(settings?.startDate ?? Date())")
                            print("‚öôÔ∏è - startDate ISO: \(ISO8601DateFormatter().string(from: settings?.startDate ?? Date()))")
                            print("‚öôÔ∏è - timezone: \(settings?.timezone ?? "unknown")")
                            
                            if oldCurrentDay != settings?.currentDay {
                                print("üö® CHANGEMENT CURRENTDAY D√âTECT√â! \(oldCurrentDay) ‚Üí \(settings?.currentDay ?? 0)")
                                print("üö® - MOMENT EXACT: \(timeFormatter.string(from: currentTime))")
                                print("üö® - D√âCLENCHEUR: settings re√ßus de Firestore")
                                
                                // üîß NOUVEAU: Calculer si c'est normal selon l'heure
                                let localCalendar = Calendar.current
                                let startOfToday = localCalendar.startOfDay(for: Date())
                                print("üö® - startOfDay local: \(startOfToday)")
                                print("üö® - Heures depuis minuit: \(Calendar.current.dateComponents([.hour, .minute], from: startOfToday, to: currentTime))")
                            } else {
                                print("‚ö†Ô∏è CURRENTDAY INCHANG√â: \(settings?.currentDay ?? 0)")
                            }
                            
                print("‚úÖ DailyQuestionService: Settings charg√©s pour couple \(coupleId)")
                        } catch {
                            print("‚ùå DailyQuestionService: Erreur d√©codage settings - \(error)")
                        }
                    }
                }
            }
    }
    
    // CORRECTION: M√©thode pour cr√©er DailyQuestionSettings depuis Firestore
    private func createSettingsFromFirestore(_ data: [String: Any], coupleId: String) throws -> DailyQuestionSettings {
        let startDate: Date
        if let timestamp = data["startDate"] as? Timestamp {
            startDate = timestamp.dateValue()
        } else {
            startDate = Date()
        }
        
        let timezone = data["timezone"] as? String ?? "Europe/Paris"
        let currentDay = data["currentDay"] as? Int ?? 1
        
        var settings = DailyQuestionSettings(coupleId: coupleId, startDate: startDate, timezone: timezone)
        settings.currentDay = currentDay
        
        if let lastVisitTimestamp = data["lastVisitDate"] as? Timestamp {
            settings.lastVisitDate = lastVisitTimestamp.dateValue()
        }
        
        return settings
    }
    
    private func setupQuestionsListener(for coupleId: String) {
        questionListener?.remove()
        
        print("üî• DailyQuestionService: √âcoute des questions pour couple: \(coupleId)")
        
        questionListener = db.collection("dailyQuestions")
            .whereField("coupleId", isEqualTo: coupleId)
            .order(by: "scheduledDateTime", descending: true)
            .limit(to: 10)
            .addSnapshotListener { [weak self] snapshot, error in
                Task { @MainActor in
                    print("üéØ DailyQuestionService: Listener d√©clench√©")
                    
                    if let error = error {
                        print("‚ùå DailyQuestionService: Erreur questions - \(error)")
                        
                        // Fallback vers le cache Realm en cas d'erreur
                        await self?.loadFromRealmCache(coupleId: coupleId)
                        return
                    }
                    
                    guard let documents = snapshot?.documents else { 
                        print("‚ùå DailyQuestionService: Aucun document dans snapshot")
                        // Fallback vers le cache Realm si pas de documents
                        await self?.loadFromRealmCache(coupleId: coupleId)
                        return 
                    }
                    
                    print("üìä DailyQuestionService: \(documents.count) document(s) trouv√©(s) dans Firestore")
                    
                    // Logs d√©taill√©s des documents trouv√©s
                    for (index, document) in documents.enumerated() {
                        let data = document.data()
                        let questionKey = data["questionKey"] as? String ?? "inconnu"
                        let questionDay = data["questionDay"] as? Int ?? 0
                        let scheduledDate = data["scheduledDate"] as? String ?? "inconnu"
                        print("üìù Document \(index + 1): ID=\(document.documentID), questionKey=\(questionKey), day=\(questionDay), date=\(scheduledDate)")
                    }
                    
                    // Si pas de documents dans Firestore, essayer le cache
                    if documents.isEmpty {
                        print("‚ö†Ô∏è DailyQuestionService: Aucun document - Fallback vers cache Realm")
                        await self?.loadFromRealmCache(coupleId: coupleId)
                        return
                    }
                    
                    var questions: [DailyQuestion] = []
                    for (index, document) in documents.enumerated() {
                        do {
                            print("üîÑ DailyQuestionService: D√©codage document \(index + 1)...")
                            var question = try document.data(as: DailyQuestion.self)
                            
                            print("‚úÖ DailyQuestionService: Question d√©cod√©e - \(question.questionKey), jour \(question.questionDay)")
                            
                            // NOUVEAU: Charger les r√©ponses depuis la sous-collection
                            question = await self?.loadResponsesForQuestion(question) ?? question
                            
                            questions.append(question)
                            
                            // Cache dans Realm pour lecture hors ligne
                            QuestionCacheManager.shared.cacheDailyQuestion(question)
                        } catch {
                            print("‚ùå DailyQuestionService: Erreur d√©codage question \(index + 1) - \(error)")
                        }
                    }
                    
                    print("üìö DailyQuestionService: \(questions.count) question(s) d√©cod√©e(s) avec succ√®s")
                    
                    self?.questionHistory = questions
                    let previousCurrentQuestion = self?.currentQuestion
                    
                    print("üîÑ DailyQuestionService: Assignation currentQuestion...")
                    print("üîÑ - questions.count: \(questions.count)")
                    print("üîÑ - questions.first: \(questions.first?.questionKey ?? "nil")")
                    print("üîÑ - previousCurrentQuestion: \(previousCurrentQuestion?.questionKey ?? "nil")")
                    print("üîÑ - currentQuestion actuelle: \(self?.currentQuestion?.questionKey ?? "nil")")
                    
                    // üöÄ OPTIMISATION: √âviter les doublons si la question a d√©j√† √©t√© mise √† jour
                    let newQuestion = questions.first
                    if self?.currentQuestion?.id != newQuestion?.id {
                        print("üîÑ DailyQuestionService: Nouvelle question d√©tect√©e via listener")
                        self?.currentQuestion = newQuestion
                    } else {
                        print("üîÑ DailyQuestionService: Question d√©j√† √† jour (optimisation imm√©diate)")
                    }
                    
                    print("üîÑ DailyQuestionService: Apr√®s assignation:")
                    print("üîÑ - self.currentQuestion: \(self?.currentQuestion?.questionKey ?? "nil")")
                    
                    if let current = questions.first {
                        print("üéØ DailyQuestionService: Question actuelle d√©finie:")
                        print("   - questionKey: \(current.questionKey)")
                        print("   - questionDay: \(current.questionDay)")
                        print("   - scheduledDate: \(current.scheduledDate)")
                        print("   - id: \(current.id)")
                        print("   - üì± UI VA SE METTRE √Ä JOUR AVEC CETTE QUESTION")
                        
                        if let previous = previousCurrentQuestion {
                            print("üîÑ DailyQuestionService: Changement de question:")
                            print("   - Ancienne: \(previous.questionKey) (jour \(previous.questionDay))")
                            print("   - Nouvelle: \(current.questionKey) (jour \(current.questionDay))")
                        } else {
                            print("üÜï DailyQuestionService: PREMI√àRE QUESTION pour ce couple!")
                        }
                        
                        // Configurer listener pour les r√©ponses de la question actuelle
                        await self?.setupResponsesListener(for: current)
                        
                        // üóëÔ∏è SUPPRIM√â : Programmation notification de rappel 21h
                        // Plus besoin de notifications locales programm√©es
                    } else {
                        print("‚ùå DailyQuestionService: Aucune question actuelle d√©finie")
                        print("‚ùå - L'UI VA AFFICHER 'Aucune question disponible'")
                        print("‚ùå - V√©rifier la g√©n√©ration de question ou le cache Realm")
                    }
                    
                    print("‚úÖ DailyQuestionService: Historique charg√© - \(questions.count) questions")
            }
        }
    }
    
    // NOUVEAU: Charger les r√©ponses depuis la sous-collection
    private func loadResponsesForQuestion(_ question: DailyQuestion) async -> DailyQuestion {
        do {
            let responsesSnapshot = try await db.collection("dailyQuestions")
                .document(question.id)
                .collection("responses")
                .order(by: "respondedAt")
                .getDocuments()
            
            var responses: [QuestionResponse] = []
            for document in responsesSnapshot.documents {
                if let response = try? document.data(as: QuestionResponse.self) {
                    responses.append(response)
                }
            }
            
            var updatedQuestion = question
            updatedQuestion.responsesFromSubcollection = responses
            
            return updatedQuestion
        } catch {
            print("‚ùå DailyQuestionService: Erreur chargement r√©ponses - \(error)")
            return question
        }
    }
    
    // NOUVEAU: √âcouter les changements dans les r√©ponses de la question actuelle
    private func setupResponsesListener(for question: DailyQuestion) async {
        responsesListener?.remove()
        
        responsesListener = db.collection("dailyQuestions")
            .document(question.id)
            .collection("responses")
            .order(by: "respondedAt")
            .addSnapshotListener { [weak self] snapshot, error in
                Task { @MainActor in
                if let error = error {
                        print("‚ùå DailyQuestionService: Erreur listener r√©ponses - \(error)")
                    return
                }
                
                    guard let documents = snapshot?.documents else { return }
                    
                    var responses: [QuestionResponse] = []
                    for document in documents {
                        if let response = try? document.data(as: QuestionResponse.self) {
                            responses.append(response)
                        }
                    }
                    
                    // Mettre √† jour la question actuelle avec les nouvelles r√©ponses
                    if var currentQuestion = self?.currentQuestion, currentQuestion.id == question.id {
                        let previousResponsesCount = currentQuestion.responsesFromSubcollection.count
                        currentQuestion.responsesFromSubcollection = responses
                        self?.currentQuestion = currentQuestion
                        
                        // Mettre √† jour aussi dans l'historique
                        if let index = self?.questionHistory.firstIndex(where: { $0.id == question.id }) {
                            self?.questionHistory[index] = currentQuestion
                        }
                        
                        print("‚úÖ DailyQuestionService: R√©ponses mises √† jour - \(responses.count) r√©ponses")
                        
                        // NOUVEAU: Notifier si nouvelles r√©ponses d√©tect√©es
                        if responses.count > previousResponsesCount,
                           let newResponse = responses.last {
                            await self?.scheduleNewMessageNotification(for: currentQuestion, newResponse: newResponse)
                        }
                        
                        // üóëÔ∏è SUPPRIM√â : Mise √† jour notification de rappel
                        // Plus besoin de notifications locales programm√©es
                    }
                }
            }
    }
    
    // MARK: - Computed Properties
    
    var coupleId: String? {
        guard let currentUser = Auth.auth().currentUser,
              let appUser = appState?.currentUser,
              let partnerId = appUser.partnerId,
              !partnerId.isEmpty else {
            return nil
        }
        
        return [currentUser.uid, partnerId].sorted().joined(separator: "_")
    }
    
    // MARK: - Actions publiques
    
    func generateTodaysQuestion() async {
        guard let currentUser = Auth.auth().currentUser,
              let coupleId = coupleId else {
            print("‚ùå DailyQuestionService: Pas d'utilisateur connect√©")
            return
        }
        
        print("üöÄ DailyQuestionService: D√©but g√©n√©ration question pour couple: \(coupleId)")

        // üîß NOUVEAUX LOGS TIMEZONE D√âTAILL√âS
        print("üïê DailyQuestionService: TIMEZONE DEBUG:")
        print("üïê - Date actuelle: \(Date())")
        print("üïê - TimeZone current: \(TimeZone.current.identifier)")
        print("üïê - TimeZone current offset: \(TimeZone.current.secondsFromGMT()) secondes")
        print("üïê - Calendar timezone: \(Calendar.current.timeZone.identifier)")

        // üîß NOUVEAU: Cr√©er les settings s'ils n'existent pas encore
        var settings = currentSettings
        if settings == nil {
            print("‚öôÔ∏è DailyQuestionService: Aucun settings - Cr√©ation via Cloud Function")
            
            do {
                let result = try await functions.httpsCallable("getOrCreateDailyQuestionSettings").call([
                    "coupleId": coupleId,
                    "timezone": TimeZone.current.identifier
                ])
                
                if let data = result.data as? [String: Any],
                   let success = data["success"] as? Bool,
                   success,
                   let settingsData = data["settings"] as? [String: Any] {
                    
                    print("‚úÖ DailyQuestionService: Settings cr√©√©s/r√©cup√©r√©s via Cloud Function")
                    
                    // Le listener des settings se d√©clenchera automatiquement
                    // On attend un petit d√©lai pour que currentSettings soit mis √† jour
                    for attempt in 1...5 {
                        if currentSettings != nil {
                            settings = currentSettings
                            print("‚úÖ DailyQuestionService: Settings disponibles apr√®s tentative \(attempt)")
                            break
                        }
                        print("‚è≥ DailyQuestionService: Attente settings (tentative \(attempt)/5)")
                        try await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconde
                    }
                    
                    if settings == nil {
                        print("‚ùå DailyQuestionService: Settings toujours indisponibles apr√®s 2.5s")
                        return
                    }
                } else {
                    print("‚ùå DailyQuestionService: Erreur r√©ponse getOrCreateDailyQuestionSettings")
                    return
                }
            } catch {
                print("‚ùå DailyQuestionService: Erreur getOrCreateDailyQuestionSettings: \(error)")
                return
            }
        }
        
        guard let finalSettings = settings else {
            print("‚ùå DailyQuestionService: Settings toujours indisponibles")
            return
        }
        
        print("‚öôÔ∏è SETTINGS CHARG√âS:")
        print("‚öôÔ∏è - startDate: \(finalSettings.startDate)")
        print("‚öôÔ∏è - startDate ISO: \(ISO8601DateFormatter().string(from: finalSettings.startDate))")
        print("‚öôÔ∏è - currentDay: \(finalSettings.currentDay)")
        print("‚öôÔ∏è - timezone: \(finalSettings.timezone)")
        
        // üîß NOUVEAU: Comparaison avec diff√©rents calendriers
        let localCalendar = Calendar.current
        let utcCalendar = Calendar(identifier: .gregorian)
        var utcCal = utcCalendar
        utcCal.timeZone = TimeZone(identifier: "UTC")!
        
        print("üóìÔ∏è CALENDRIER COMPARAISON:")
        print("üóìÔ∏è - Local startOfDay: \(localCalendar.startOfDay(for: Date()))")
        print("üóìÔ∏è - UTC startOfDay: \(utcCal.startOfDay(for: Date()))")
        print("üóìÔ∏è - Settings startDate local: \(localCalendar.startOfDay(for: finalSettings.startDate))")
        print("üóìÔ∏è - Settings startDate UTC: \(utcCal.startOfDay(for: finalSettings.startDate))")

        // V√©rifier si une nouvelle question doit r√©ellement √™tre g√©n√©r√©e (apr√®s 21h)
        if DailyQuestionGenerator.shouldShowNewQuestion(settings: finalSettings) == false {
            print("‚ÑπÔ∏è DailyQuestionService: Pas encore l'heure de la nouvelle question ‚Äì g√©n√©ration annul√©e")
            print("üîç ANALYSE: settings.currentDay=\(finalSettings.currentDay), expectedDay calcul√© ci-dessus")
            print("üîç SUGGESTION: V√©rifier la logique shouldShowNewQuestion")
            return
        }
        
        print("‚úÖ DailyQuestionService: shouldShowNewQuestion = true, g√©n√©ration autoris√©e!")
        
        isLoading = true
        defer { isLoading = false }

        do {
            // Calculer le jour attendu bas√© sur le temps √©coul√©
            let expectedDay = DailyQuestionGenerator.calculateCurrentQuestionDay(for: coupleId, settings: finalSettings) ?? finalSettings.currentDay
            
            print("‚öôÔ∏è CALCUL EXPECTEDDAY:")
            print("‚öôÔ∏è - expectedDay calcul√©: \(expectedDay)")
            print("‚öôÔ∏è - settings.currentDay: \(finalSettings.currentDay)")
            print("‚öôÔ∏è - Question sera g√©n√©r√©e pour le jour: \(expectedDay)")
            
            // CORRECTION TIMEZONE: Utiliser UTC pour √©viter les probl√®mes startOfDay
            var calendar = Calendar(identifier: .gregorian)
            calendar.timeZone = TimeZone(identifier: "UTC")!
            let startOfDay = calendar.startOfDay(for: finalSettings.startDate)
            let startOfToday = calendar.startOfDay(for: Date())
            let daysSinceStart = calendar.dateComponents([.day], from: startOfDay, to: startOfToday).day ?? 0
            
            print("‚öôÔ∏è DATES (UTC FIXED):")
            print("‚öôÔ∏è - startOfDay: \(startOfDay)")
            print("‚öôÔ∏è - startOfToday: \(startOfToday)")
            print("‚öôÔ∏è - daysSinceStart: \(daysSinceStart)")
            
            print("üåê APPEL CLOUD FUNCTION:")
            print("üåê - coupleId: \(coupleId)")
            print("üåê - userId: \(currentUser.uid)")
            print("üåê - questionDay: \(expectedDay)")
            print("üåê - timezone: \(TimeZone.current.identifier)")
            print("üåê - D√©but appel generateDailyQuestion...")
            
            let result = try await functions.httpsCallable("generateDailyQuestion").call([
                "coupleId": coupleId,
                "userId": currentUser.uid,
                "questionDay": expectedDay,
                "timezone": TimeZone.current.identifier
            ])

            print("üì• R√âPONSE CLOUD FUNCTION:")
            print("üì• - Raw result: \(result)")
            print("üì• - Result data: \(result.data)")
            
            if let data = result.data as? [String: Any],
               let success = data["success"] as? Bool,
               success {
                    print("‚úÖ Question g√©n√©r√©e avec succ√®s")
                    print("‚úÖ - Donn√©es compl√®tes: \(data)")
                
                if let questionData = data["question"] as? [String: Any] {
                    let questionKey = questionData["questionKey"] as? String ?? "inconnu"
                    let questionDay = questionData["questionDay"] as? Int ?? 0
                    print("‚öôÔ∏è - questionKey re√ßue: \(questionKey)")
                    print("‚öôÔ∏è - questionDay retourn√©: \(questionDay)")
                    print("‚öôÔ∏è - questionData compl√®te: \(questionData)")
                    
                    // üöÄ OPTIMISATION: Cr√©er imm√©diatement la question pour l'UI
                    // au lieu d'attendre le listener Firestore
                    if let questionId = questionData["id"] as? String,
                       let scheduledDate = questionData["scheduledDate"] as? String,
                       let status = questionData["status"] as? String {
                        
                        let immediateQuestion = DailyQuestion(
                            id: questionId,
                            coupleId: coupleId,
                            questionKey: questionKey,
                            questionDay: questionDay,
                            scheduledDate: scheduledDate,
                            scheduledDateTime: Date(), // Approximation pour l'UI
                            status: QuestionStatus(rawValue: status) ?? .pending,
                            createdAt: Date(),
                            updatedAt: Date(),
                            timezone: TimeZone.current.identifier,
                            responsesFromSubcollection: [],
                            legacyResponses: [:]
                        )
                        
                        print("üöÄ DailyQuestionService: Mise √† jour imm√©diate UI avec question g√©n√©r√©e")
                        self.currentQuestion = immediateQuestion
                        
                        // Cache imm√©diatement dans Realm
                        QuestionCacheManager.shared.cacheDailyQuestion(immediateQuestion)
                        print("üöÄ DailyQuestionService: Question mise en cache imm√©diatement")
                    }
                }
                
                if let message = data["message"] as? String {
                    print("üí¨ - Message serveur: \(message)")
                }
                
                if let existingQuestion = data["existingQuestion"] as? [String: Any] {
                    print("üîÑ - Question existante d√©tect√©e: \(existingQuestion)")
                }
                
                // Mettre √† jour le jour courant vers le jour attendu
                if var settings = self.currentSettings {
                    settings.currentDay = expectedDay
                    self.currentSettings = settings
                    print("‚öôÔ∏è Settings mis √† jour localement - currentDay: \(expectedDay)")

                    // Mettre √† jour Firestore pour persister le nouveau currentDay
                    if let coupleId = self.coupleId {
                        do {
                            try await db.collection("dailyQuestionSettings")
                                .document(coupleId)
                                .updateData(["currentDay": settings.currentDay,
                                             "lastVisitDate": Timestamp(date: Date())])
                            print("‚úÖ DailyQuestionService: currentDay mis √† jour ‚Üí \(settings.currentDay)")
                        } catch {
                            print("‚ùå DailyQuestionService: Impossible de mettre √† jour currentDay - \(error)")
                        }
                    }
                }

                if let exhausted = data["allQuestionsExhausted"] as? Bool, exhausted {
                    allQuestionsExhausted = true
                    print("‚ö†Ô∏è DailyQuestionService: Toutes les questions √©puis√©es")
                    }
                } else {
                    print("‚ùå DailyQuestionService: √âchec g√©n√©ration question")
                    print("‚ùå - Donn√©es re√ßues: \(result.data)")
                    
                    if let data = result.data as? [String: Any] {
                        if let success = data["success"] as? Bool {
                            print("‚ùå - success = \(success)")
                        }
                        if let error = data["error"] as? String {
                            print("‚ùå - Erreur serveur: \(error)")
                        }
                        if let message = data["message"] as? String {
                            print("‚ùå - Message serveur: \(message)")
                        }
                    }
            }
        } catch {
            print("‚ùå DailyQuestionService: Erreur g√©n√©ration - \(error)")
            print("‚ùå - Type d'erreur: \(type(of: error))")
            print("‚ùå - Description compl√®te: \(error.localizedDescription)")
            
            if let functionsError = error as NSError? {
                print("‚ùå - Functions error code: \(functionsError.code)")
                print("‚ùå - Functions error domain: \(functionsError.domain)")
                print("‚ùå - Functions error userInfo: \(functionsError.userInfo)")
            }
        }
    }
    
    // NOUVEAU: Soumettre une r√©ponse via le syst√®me de sous-collections
    func submitResponse(_ responseText: String) async -> Bool {
        guard let currentUser = Auth.auth().currentUser,
              let userName = appState?.currentUser?.name,
              let question = currentQuestion else {
            print("‚ùå DailyQuestionService: Donn√©es manquantes pour la r√©ponse")
            return false
        }
        
        print("üî• DailyQuestionService: Soumission r√©ponse:")
        print("   - Question ID: \(question.id)")
        print("   - Utilisateur: \(currentUser.uid)")
        print("   - Nom: \(userName)")
        print("   - Texte: '\(responseText)'")
        print("üî• DailyQuestionService: Cette action devrait d√©clencher notifyPartnerResponseSubcollection")
        
        do {
            let result = try await functions.httpsCallable("submitDailyQuestionResponse").call([
                "questionId": question.id,
                "responseText": responseText,
                "userName": userName
            ])
            
            if let data = result.data as? [String: Any],
               let success = data["success"] as? Bool,
               success {
            print("‚úÖ DailyQuestionService: R√©ponse soumise avec succ√®s")
            print("üì® DailyQuestionService: Cloud Function devrait envoyer push au partenaire maintenant")
            return true
            } else {
                print("‚ùå DailyQuestionService: √âchec soumission r√©ponse")
                if let data = result.data as? [String: Any],
                   let message = data["message"] as? String {
                    print("‚ùå DailyQuestionService: Message: \(message)")
                }
                return false
            }
        } catch {
            print("‚ùå DailyQuestionService: Erreur soumission - \(error)")
            return false
        }
    }
    
    // MARK: - Migration Support
    
    func migrateTodaysQuestionToSubcollections() async -> Bool {
        guard let currentUser = Auth.auth().currentUser,
              let coupleId = coupleId else {
            print("‚ùå DailyQuestionService: Pas d'utilisateur connect√© pour migration")
            return false
        }
        
        do {
            let result = try await functions.httpsCallable("migrateDailyQuestionResponses").call([
                "coupleId": coupleId
            ])
            
            if let data = result.data as? [String: Any],
               let success = data["success"] as? Bool,
               success {
                print("‚úÖ DailyQuestionService: Migration r√©ussie")
                return true
            } else {
                print("‚ùå DailyQuestionService: √âchec migration")
                return false
            }
        } catch {
            print("‚ùå DailyQuestionService: Erreur migration - \(error)")
            return false
        }
    }
    
    // MARK: - Helpers
    
    // üóëÔ∏è FONCTION SUPPRIM√âE : scheduleDailyQuestionReminder
    // Cette fonction programmait des notifications locales iOS √† 21h pour rappeler les questions
    // SUPPRIM√âE car seules les notifications de messages entre partenaires sont souhait√©es
    
    // MARK: - Notifications pour nouveaux messages
    
    private func scheduleNewMessageNotification(for question: DailyQuestion, newResponse: QuestionResponse) async {
        // Ne notifier que si le message vient du partenaire
        guard let currentUserId = Auth.auth().currentUser?.uid,
              newResponse.userId != currentUserId else {
            print("üîî DailyQuestionService: Message de l'utilisateur actuel ‚Äì pas de notification")
            return
        }
        
        let center = UNUserNotificationCenter.current()
        let identifier = "new_message_\(question.id)_\(newResponse.id)"
        
        // Supprimer les anciennes notifications pour cette question pour √©viter l'accumulation
        let questionNotificationPrefix = "new_message_\(question.id)_"
        let pendingRequests = await center.pendingNotificationRequests()
        let oldNotificationIds = pendingRequests
            .filter { $0.identifier.hasPrefix(questionNotificationPrefix) && $0.identifier != identifier }
            .map { $0.identifier }
        
        if !oldNotificationIds.isEmpty {
            center.removePendingNotificationRequests(withIdentifiers: oldNotificationIds)
            print("üóëÔ∏è DailyQuestionService: \(oldNotificationIds.count) anciennes notifications supprim√©es pour question \(question.id)")
        }
        
        let content = UNMutableNotificationContent()
        // üéØ FORMAT SIMPLIFI√â : Nom partenaire en titre, message complet en body
        content.title = newResponse.userName
        content.body = newResponse.text
        content.sound = .default
        content.badge = 1
        
        // Notification imm√©diate pour nouveau message
        let request = UNNotificationRequest(identifier: identifier, content: content, trigger: nil)
        
        print("üîî DailyQuestionService: Programmation notification nouveau message:")
        print("   - ID: \(identifier)")
        print("   - De: \(newResponse.userName)")
        print("   - Preview: \(String(newResponse.text.prefix(30)))...")
        
        do {
            try await center.add(request)
            print("‚úÖ DailyQuestionService: Notification nouveau message programm√©e")
        } catch {
            print("‚ùå DailyQuestionService: Erreur notification nouveau message - \(error)")
        }
    }
    
    /// Nettoie toutes les notifications en attente et remet le badge √† 0
    func clearAllNotificationsAndBadge() {
        print("üßπ DailyQuestionService: Nettoyage notifications et badge")
        BadgeManager.clearAllNotificationsAndBadge()
    }
    
    /// Nettoie les notifications sp√©cifiques √† une question
    func clearNotificationsForQuestion(_ questionId: String) {
        let questionNotificationPrefix = "new_message_\(questionId)_"
        
        Task {
            let center = UNUserNotificationCenter.current()
            let pendingRequests = await center.pendingNotificationRequests()
            let notificationIds = pendingRequests
                .filter { $0.identifier.hasPrefix(questionNotificationPrefix) }
                .map { $0.identifier }
            
            if !notificationIds.isEmpty {
                center.removePendingNotificationRequests(withIdentifiers: notificationIds)
                print("üóëÔ∏è DailyQuestionService: \(notificationIds.count) notifications supprim√©es pour question \(questionId)")
            }
        }
    }
    
    
    // üóëÔ∏è FONCTION DEBUG SUPPRIM√âE : fixDailyQuestionSettings()
    // Cette fonction √©tait utilis√©e pour corriger les settings en mode debug
    // SUPPRIM√âE car plus n√©cessaire apr√®s les corrections timezone
    
    // NOUVEAU: Chargement depuis le cache Realm en cas de probl√®me Firestore
    private func loadFromRealmCache(coupleId: String) async {
        print("üîÑ DailyQuestionService: Chargement depuis le cache Realm pour couple: \(coupleId)")
        print("üîÑ - RAISON: Fallback car Firestore n'a pas de documents ou erreur")
        
        let cachedQuestions = QuestionCacheManager.shared.getCachedDailyQuestions(for: coupleId, limit: 10)
        
        print("üì¶ DailyQuestionService: \(cachedQuestions.count) questions trouv√©es dans le cache Realm")
        
        // Logs d√©taill√©s des questions en cache
        for (index, question) in cachedQuestions.enumerated() {
            print("üìù Cache \(index + 1): questionKey=\(question.questionKey), day=\(question.questionDay), date=\(question.scheduledDate)")
        }
        
        if !cachedQuestions.isEmpty {
            print("‚úÖ DailyQuestionService: Application des questions du cache...")
            
            self.questionHistory = cachedQuestions
            self.currentQuestion = cachedQuestions.first
            
            print("‚úÖ DailyQuestionService: \(cachedQuestions.count) questions charg√©es depuis le cache")
            print("‚úÖ - currentQuestion assign√©e: \(self.currentQuestion?.questionKey ?? "nil")")
            print("‚úÖ - üì± UI DEVRAIT SE METTRE √Ä JOUR AVEC QUESTION DU CACHE")
            
            if let current = cachedQuestions.first {
                print("üéØ DailyQuestionService: Question actuelle charg√©e depuis le cache:")
                print("   - questionKey: \(current.questionKey)")
                print("   - questionDay: \(current.questionDay)")
                print("   - scheduledDate: \(current.scheduledDate)")
                print("   - id: \(current.id)")
            }
        } else {
            print("‚ùå DailyQuestionService: Aucune question trouv√©e dans le cache")
            print("‚ùå - self.currentQuestion reste: \(self.currentQuestion?.questionKey ?? "nil")")
            print("‚ùå - üì± UI VA AFFICHER 'Aucune question disponible'")
            print("‚ùå - PROBL√àME: Ni Firestore ni cache Realm n'ont de questions!")
        }
    }
    
    func shouldAutoMigrate() -> Bool {
        // Auto-migrer si on d√©tecte l'ancien format
        return currentQuestion?.shouldUseLegacyMode == true
    }
    
    func refreshCurrentQuestion() async {
        // Forcer un refresh des donn√©es
        setupListeners()
    }
    
    func loadQuestionHistory() async {
        // Pour les statistiques seulement : charger l'historique r√©cent
        guard let coupleId = coupleId else {
            print("‚ùå DailyQuestionService: Pas de coupleId pour l'historique")
            return
        }
        
        do {
            let snapshot = try await db.collection("dailyQuestions")
                .whereField("coupleId", isEqualTo: coupleId)
                .order(by: "scheduledDate", descending: true)
                .limit(to: 30) // Seulement les 30 derni√®res pour les stats
                .getDocuments()
            
            var questions: [DailyQuestion] = []
            
            for document in snapshot.documents {
                do {
                    var question = try document.data(as: DailyQuestion.self)
                    question = await loadResponsesForQuestion(question)
                    questions.append(question)
                } catch {
                    print("‚ùå DailyQuestionService: Erreur d√©codage question historique - \(error)")
                }
            }
            
            questionHistory = questions
            print("üìä DailyQuestionService: \(questions.count) questions charg√©es pour statistiques")
        } catch {
            print("‚ùå DailyQuestionService: Erreur chargement historique - \(error)")
        }
    }
    
    // MARK: - üåç TIMEZONE OPTIMIZATION WITH REALM CACHE
    
    /// üöÄ Optimisation timezone avec cache Realm - r√©duit drastiquement les co√ªts Firebase
    func checkForNewQuestionWithTimezoneOptimization() async {
        // üéØ √âTAT DE CHARGEMENT POUR L'UI
        await MainActor.run {
            self.isOptimizing = true
        }
        
        defer {
            Task { @MainActor in
                self.isOptimizing = false
            }
        }
        
        let startTime = Date()
        print("\nüåç === TIMEZONE OPTIMIZATION START ===")
        print("üïê Heure locale: \(DateFormatter.timeFormatter.string(from: Date()))")
        print("üåç Timezone: \(TimeZone.current.identifier)")
        print("üîÑ isOptimizing = true ‚Üí UI va afficher √©tat de chargement")
        
        guard let coupleId = coupleId else {
            print("‚ùå Pas de coupleId - arr√™t")
            return
        }
        
        // üì¶ 1. CHECK CACHE REALM EN PREMIER
        print("\nüì¶ Phase 1: V√©rification cache Realm")
        let cachedQuestions = QuestionCacheManager.shared.getCachedDailyQuestions(for: coupleId, limit: 5)
        
        print("üìã \(cachedQuestions.count) questions trouv√©es dans le cache")
        for (index, question) in cachedQuestions.enumerated() {
            print("   \(index + 1). \(question.questionKey) - Jour \(question.questionDay) - \(question.scheduledDate)")
        }
        
        // üïê 2. ANALYSE TIMEZONE LOCALE
        print("\nüïê Phase 2: Analyse timezone locale")
        let localTime = Date()
        let calendar = Calendar.current
        let hour = calendar.component(.hour, from: localTime)
        let minute = calendar.component(.minute, from: localTime)
        let today = DateFormatter.dayFormatter.string(from: localTime)
        
        print("‚è∞ Heure exacte: \(hour):\(String(format: "%02d", minute))")
        print("üìÖ Date aujourd'hui: \(today)")
        
        // üéØ 3. CHECK SI NOUVELLE QUESTION ATTENDUE
        print("\nüéØ Phase 3: Check nouvelle question attendue")
        
        let todaysQuestion = cachedQuestions.first { $0.scheduledDate == today }
        
        if let existingQuestion = todaysQuestion {
            print("‚úÖ Question d'aujourd'hui d√©j√† en cache:")
            print("   - questionKey: \(existingQuestion.questionKey)")
            print("   - questionDay: \(existingQuestion.questionDay)")
            print("   - Pas besoin d'appel Firebase")
            
            // üîÑ Mettre √† jour l'UI si n√©cessaire
            if currentQuestion?.questionKey != existingQuestion.questionKey {
                print("üîÑ Mise √† jour UI avec question cach√©e")
                DispatchQueue.main.async {
                    self.currentQuestion = existingQuestion
                }
            }
            
            print("‚ö° Optimisation Realm: 0 appel Firebase n√©cessaire")
            return
        }
        
        // üïê 4. CHECK TIMING POUR APPEL FIREBASE
        print("\nüïê Phase 4: Check timing pour appel Firebase")
        
        // √âviter les appels inutiles - check seulement aux heures critiques
        let shouldCheckFirebase = isCriticalTimeForFirebaseCheck(hour: hour, minute: minute)
        
        // NOUVEAU: Si aucune question en cache OU aucune question pour aujourd'hui, on force l'appel Firebase
        let forceFirebaseBecauseNoCache = cachedQuestions.isEmpty
        let forceFirebaseBecauseNoToday   = todaysQuestion == nil
        if !shouldCheckFirebase && !forceFirebaseBecauseNoCache && !forceFirebaseBecauseNoToday {
            print("‚è≠Ô∏è  Heure non critique (\(hour):\(String(format: "%02d", minute))) - Skip appel Firebase")
            print("üéØ Heures critiques: 00:00-00:05, 21:00-21:05")
            
            // Utiliser la derni√®re question du cache
            if let lastQuestion = cachedQuestions.first {
                print("üì¶ Utilisation derni√®re question du cache: \(lastQuestion.questionKey)")
                DispatchQueue.main.async {
                    self.currentQuestion = lastQuestion
                }
            }
            
            let executionTime = Date().timeIntervalSince(startTime)
            print("‚ö° Temps d'ex√©cution: \(Int(executionTime * 1000))ms")
            print("üåç === TIMEZONE OPTIMIZATION END (CACHE ONLY) ===\n")
            return
        }
        if !shouldCheckFirebase {
            print("‚ö†Ô∏è Aucun cache local pour aujourd'hui - Appel Firebase forc√© malgr√© heure non critique")
        }
        
        // üöÄ 5. APPEL FIREBASE OPTIMIS√â
        print("\nüöÄ Phase 5: Appel Firebase optimis√© n√©cessaire")
        print("‚è∞ Heure critique d√©tect√©e - v√©rification Firebase")
        
        // Sauvegarder les stats d'optimisation  
        let optimizationStats = TimezoneOptimizationStats(
            cacheHits: cachedQuestions.count,
            firebaseCallAvoided: false,
            criticalTime: true,
            timezone: TimeZone.current.identifier,
            localHour: hour
        )
        
        // Appel Firebase intelligent avec les donn√©es du cache
        await intelligentFirebaseCall(optimizationStats: optimizationStats)
        
        let executionTime = Date().timeIntervalSince(startTime)
        print("‚ö° Temps d'ex√©cution total: \(Int(executionTime * 1000))ms")
        print("üåç === TIMEZONE OPTIMIZATION END (FIREBASE CALLED) ===\n")
    }
    
    /// üïê D√©termine si c'est une heure critique pour checker Firebase
    private func isCriticalTimeForFirebaseCheck(hour: Int, minute: Int) -> Bool {
        // ‚úÖ 00:00-00:05 : Nouvelles questions possibles
        if hour == 0 && minute <= 5 {
            print("üéØ Heure critique: Minuit - nouvelles questions possibles")
            return true
        }
        
        // üîî 21:00-21:05 : Notifications de rappel
        if hour == 21 && minute <= 5 {
            print("üîî Heure critique: 21h - notifications de rappel")
            return true
        }
        
        // ‚è∞ Autres heures critiques (si settings sp√©ciaux)
        if let settings = currentSettings {
            // Check personnalis√© selon les pr√©f√©rences du couple
            // TODO: Ajouter logique personnalis√©e si n√©cessaire
        }
        
        return false
    }
    
    /// üöÄ Appel Firebase intelligent avec optimisations
    private func intelligentFirebaseCall(optimizationStats: TimezoneOptimizationStats) async {
        print("üöÄ intelligentFirebaseCall: D√©but appel optimis√©")
        
        do {
            // Pr√©parer les param√®tres avec timezone locale
            let callParams: [String: Any] = [
                "timezone": TimeZone.current.identifier,
                "localHour": optimizationStats.localHour,
                "cacheStats": [
                    "cacheHits": optimizationStats.cacheHits,
                    "lastCacheUpdate": Date().timeIntervalSince1970
                ]
            ]
            
            print("üì§ Param√®tres envoy√©s:")
            print("   - timezone: \(TimeZone.current.identifier)")
            print("   - localHour: \(optimizationStats.localHour)")
            print("   - cacheHits: \(optimizationStats.cacheHits)")
            
            // Appeler la fonction de g√©n√©ration standard
            await generateTodaysQuestion()
            
            print("‚úÖ Appel Firebase termin√© avec succ√®s")
            
        } catch {
            print("‚ùå Erreur appel Firebase: \(error.localizedDescription)")
            
            // Fallback sur le cache en cas d'erreur
            await fallbackToCache()
        }
    }
    
    /// üì¶ Fallback sur le cache en cas d'erreur Firebase
    private func fallbackToCache() async {
        print("üì¶ Fallback: Utilisation cache Realm suite √† erreur Firebase")
        
        guard let coupleId = coupleId else { return }
        
        let cachedQuestions = QuestionCacheManager.shared.getCachedDailyQuestions(for: coupleId, limit: 1)
        
        if let latestQuestion = cachedQuestions.first {
            print("‚úÖ Question de fallback trouv√©e: \(latestQuestion.questionKey)")
            
            DispatchQueue.main.async {
                self.currentQuestion = latestQuestion
            }
        } else {
            print("‚ùå Aucune question en cache pour fallback")
        }
    }
    
    // MARK: - üìä STATS & MONITORING
    
    /// üìä Stats d'optimisation timezone pour monitoring
    struct TimezoneOptimizationStats {
        let cacheHits: Int
        let firebaseCallAvoided: Bool
        let criticalTime: Bool
        let timezone: String
        let localHour: Int
        let timestamp: Date = Date()
        
        func logSummary() {
            print("üìä OPTIMISATION STATS:")
            print("   üíæ Cache hits: \(cacheHits)")
            print("   üöÄ Firebase √©vit√©: \(firebaseCallAvoided ? "‚úÖ" : "‚ùå")")
            print("   üïê Heure critique: \(criticalTime ? "‚úÖ" : "‚ùå")")
            print("   üåç Timezone: \(timezone)")
            print("   ‚è∞ Heure locale: \(localHour)h")
        }
    }
    
    /// üîÑ Fonction d'entr√©e principale optimis√©e
    func optimizedDailyQuestionCheck() async {
        print("üîÑ optimizedDailyQuestionCheck: D√©marrage check optimis√©")
        
        // Utiliser la nouvelle logique d'optimisation timezone
        await checkForNewQuestionWithTimezoneOptimization()
    }
    
    // MARK: - üåç LANGUAGE DETECTION & STORAGE
    
    /// üåç Sauvegarde la langue utilisateur dans Firebase pour les notifications localis√©es
    private func saveUserLanguageToFirebase() {
        guard let currentUser = Auth.auth().currentUser else {
            print("‚ùå DailyQuestionService: Pas d'utilisateur connect√© pour sauvegarder la langue")
            return
        }
        
        // D√©tecter la langue du syst√®me iOS
        let userLanguage = Locale.current.languageCode ?? "fr"
        
        print("üåç DailyQuestionService: Sauvegarde langue utilisateur: \(userLanguage)")
        
        // Sauvegarder dans les donn√©es utilisateur Firebase
        let userRef = Firestore.firestore().collection("users").document(currentUser.uid)
        userRef.updateData([
            "languageCode": userLanguage,
            "languageUpdatedAt": FieldValue.serverTimestamp()
        ]) { error in
            if let error = error {
                print("‚ùå DailyQuestionService: Erreur sauvegarde langue: \(error)")
            } else {
                print("‚úÖ DailyQuestionService: Langue \(userLanguage) sauvegard√©e avec succ√®s")
            }
        }
    }
}

// MARK: - Extensions pour DailyQuestion

extension DailyQuestion {
    func getCurrentUserResponse(userId: String) -> QuestionResponse? {
        return responses[userId]
    }
    
    func getPartnerResponse(excluding userId: String) -> QuestionResponse? {
        return responses.values.first { $0.userId != userId }
    }
    
    func canUserRespond(userId: String) -> Bool {
        let userResponse = responses[userId]
        return userResponse?.status != .answered && !isExpired
    }
    
    func shouldShowWaitingMessage(for userId: String) -> Bool {
        let userResponse = responses[userId]
        return userResponse?.status == .answered && !bothResponded
    }
} 