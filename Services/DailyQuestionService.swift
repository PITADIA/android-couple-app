import Foundation
import FirebaseFirestore
import FirebaseAuth
import FirebaseFunctions
import Combine
import RealmSwift
import UserNotifications

@MainActor
class DailyQuestionService: ObservableObject {
    static let shared = DailyQuestionService()
    
    @Published var currentQuestion: DailyQuestion?
    @Published var questionHistory: [DailyQuestion] = []
    @Published var isLoading = false
    @Published var allQuestionsExhausted = false
    @Published var currentSettings: DailyQuestionSettings?
    
    private var db = Firestore.firestore()
    private var functions = Functions.functions()
    private var questionListener: ListenerRegistration?
    private var responsesListener: ListenerRegistration? // NOUVEAU: Listener pour sous-collections
    private var settingsListener: ListenerRegistration?
    
    // CORRECTION: R√©f√©rence weak √† AppState pour √©viter les cycles de r√©f√©rence
    private weak var appState: AppState?
    
    private init() {
        // Les listeners seront configur√©s via configure(with:)
    }
    
    deinit {
        questionListener?.remove()
        responsesListener?.remove()
        settingsListener?.remove()
    }
    
    // MARK: - Configuration
    
    func configure(with appState: AppState) {
        self.appState = appState
        setupListeners()
    }
    
    // MARK: - Setup et Lifecycle
    
    private func setupListeners() {
        guard let currentUser = Auth.auth().currentUser,
              let appState = appState,
              let currentAppUser = appState.currentUser,
              let partnerId = currentAppUser.partnerId,
              !partnerId.isEmpty else {
            print("üî• DailyQuestionService: Pas d'utilisateur connect√© ou de couple configur√©")
            return
        }
        
        // CORRECTION: Cr√©er le coupleId comme dans le reste de l'app
        let coupleId = [currentUser.uid, partnerId].sorted().joined(separator: "_")
        print("üî• DailyQuestionService: √âcoute des questions pour couple: \(coupleId)")
            
        // √âcouter les settings
        setupSettingsListener(for: coupleId)
        
        // √âcouter les questions
        setupQuestionsListener(for: coupleId)
            }
            
    private func setupSettingsListener(for coupleId: String) {
        settingsListener?.remove()
        
        settingsListener = db.collection("dailyQuestionSettings")
            .document(coupleId)
            .addSnapshotListener { [weak self] snapshot, error in
                Task { @MainActor in
                    if let error = error {
                        print("‚ùå DailyQuestionService: Erreur settings - \(error)")
            return
        }
        
                    if let data = snapshot?.data() {
                        print("‚öôÔ∏è SETTINGS FIRESTORE RE√áUS:")
                        print("‚öôÔ∏è - Raw data: \(data)")
                        
                        do {
                            let oldCurrentDay = self?.currentSettings?.currentDay ?? 0
                            let settings = try self?.createSettingsFromFirestore(data, coupleId: coupleId)
                            self?.currentSettings = settings
                            
                            print("‚öôÔ∏è SETTINGS LISTENER UPDATE:")
                            print("‚öôÔ∏è - Ancien currentDay: \(oldCurrentDay)")
                            print("‚öôÔ∏è - Nouveau currentDay: \(settings?.currentDay ?? 0)")
                            print("‚öôÔ∏è - startDate: \(settings?.startDate ?? Date())")
                            print("‚öôÔ∏è - timezone: \(settings?.timezone ?? "unknown")")
                            
                            if oldCurrentDay != settings?.currentDay {
                                print("üö® CHANGEMENT CURRENTDAY D√âTECT√â! \(oldCurrentDay) ‚Üí \(settings?.currentDay ?? 0)")
                            } else {
                                print("‚ö†Ô∏è CURRENTDAY INCHANG√â: \(settings?.currentDay ?? 0)")
                            }
                            
                print("‚úÖ DailyQuestionService: Settings charg√©s pour couple \(coupleId)")
                        } catch {
                            print("‚ùå DailyQuestionService: Erreur d√©codage settings - \(error)")
                        }
                    }
                }
            }
    }
    
    // CORRECTION: M√©thode pour cr√©er DailyQuestionSettings depuis Firestore
    private func createSettingsFromFirestore(_ data: [String: Any], coupleId: String) throws -> DailyQuestionSettings {
        let startDate: Date
        if let timestamp = data["startDate"] as? Timestamp {
            startDate = timestamp.dateValue()
        } else {
            startDate = Date()
        }
        
        let timezone = data["timezone"] as? String ?? "Europe/Paris"
        let currentDay = data["currentDay"] as? Int ?? 1
        
        var settings = DailyQuestionSettings(coupleId: coupleId, startDate: startDate, timezone: timezone)
        settings.currentDay = currentDay
        
        if let lastVisitTimestamp = data["lastVisitDate"] as? Timestamp {
            settings.lastVisitDate = lastVisitTimestamp.dateValue()
        }
        
        return settings
    }
    
    private func setupQuestionsListener(for coupleId: String) {
        questionListener?.remove()
        
        print("üî• DailyQuestionService: √âcoute des questions pour couple: \(coupleId)")
        
        questionListener = db.collection("dailyQuestions")
            .whereField("coupleId", isEqualTo: coupleId)
            .order(by: "scheduledDateTime", descending: true)
            .limit(to: 10)
            .addSnapshotListener { [weak self] snapshot, error in
                Task { @MainActor in
                    print("üéØ DailyQuestionService: Listener d√©clench√©")
                    
                    if let error = error {
                        print("‚ùå DailyQuestionService: Erreur questions - \(error)")
                        
                        // Fallback vers le cache Realm en cas d'erreur
                        await self?.loadFromRealmCache(coupleId: coupleId)
                        return
                    }
                    
                    guard let documents = snapshot?.documents else { 
                        print("‚ùå DailyQuestionService: Aucun document dans snapshot")
                        // Fallback vers le cache Realm si pas de documents
                        await self?.loadFromRealmCache(coupleId: coupleId)
                        return 
                    }
                    
                    print("üìä DailyQuestionService: \(documents.count) document(s) trouv√©(s) dans Firestore")
                    
                    // Logs d√©taill√©s des documents trouv√©s
                    for (index, document) in documents.enumerated() {
                        let data = document.data()
                        let questionKey = data["questionKey"] as? String ?? "inconnu"
                        let questionDay = data["questionDay"] as? Int ?? 0
                        let scheduledDate = data["scheduledDate"] as? String ?? "inconnu"
                        print("üìù Document \(index + 1): ID=\(document.documentID), questionKey=\(questionKey), day=\(questionDay), date=\(scheduledDate)")
                    }
                    
                    // Si pas de documents dans Firestore, essayer le cache
                    if documents.isEmpty {
                        print("‚ö†Ô∏è DailyQuestionService: Aucun document - Fallback vers cache Realm")
                        await self?.loadFromRealmCache(coupleId: coupleId)
                        return
                    }
                    
                    var questions: [DailyQuestion] = []
                    for (index, document) in documents.enumerated() {
                        do {
                            print("üîÑ DailyQuestionService: D√©codage document \(index + 1)...")
                            var question = try document.data(as: DailyQuestion.self)
                            
                            print("‚úÖ DailyQuestionService: Question d√©cod√©e - \(question.questionKey), jour \(question.questionDay)")
                            
                            // NOUVEAU: Charger les r√©ponses depuis la sous-collection
                            question = await self?.loadResponsesForQuestion(question) ?? question
                            
                            questions.append(question)
                            
                            // Cache dans Realm pour lecture hors ligne
                            QuestionCacheManager.shared.cacheDailyQuestion(question)
                        } catch {
                            print("‚ùå DailyQuestionService: Erreur d√©codage question \(index + 1) - \(error)")
                        }
                    }
                    
                    print("üìö DailyQuestionService: \(questions.count) question(s) d√©cod√©e(s) avec succ√®s")
                    
                    self?.questionHistory = questions
                    let previousCurrentQuestion = self?.currentQuestion
                    self?.currentQuestion = questions.first
                    
                    if let current = questions.first {
                        print("üéØ DailyQuestionService: Question actuelle d√©finie:")
                        print("   - questionKey: \(current.questionKey)")
                        print("   - questionDay: \(current.questionDay)")
                        print("   - scheduledDate: \(current.scheduledDate)")
                        print("   - id: \(current.id)")
                        
                        if let previous = previousCurrentQuestion {
                            print("üîÑ DailyQuestionService: Changement de question:")
                            print("   - Ancienne: \(previous.questionKey) (jour \(previous.questionDay))")
                            print("   - Nouvelle: \(current.questionKey) (jour \(current.questionDay))")
                        }
                        
                        // Configurer listener pour les r√©ponses de la question actuelle
                        await self?.setupResponsesListener(for: current)
                        
                        // Programmer la notification de rappel √† 21h si n√©cessaire
                        await self?.scheduleDailyQuestionReminder(for: current)
                    } else {
                        print("‚ùå DailyQuestionService: Aucune question actuelle d√©finie")
                    }
                    
                    print("‚úÖ DailyQuestionService: Historique charg√© - \(questions.count) questions")
            }
        }
    }
    
    // NOUVEAU: Charger les r√©ponses depuis la sous-collection
    private func loadResponsesForQuestion(_ question: DailyQuestion) async -> DailyQuestion {
        do {
            let responsesSnapshot = try await db.collection("dailyQuestions")
                .document(question.id)
                .collection("responses")
                .order(by: "respondedAt")
                .getDocuments()
            
            var responses: [QuestionResponse] = []
            for document in responsesSnapshot.documents {
                if let response = try? document.data(as: QuestionResponse.self) {
                    responses.append(response)
                }
            }
            
            var updatedQuestion = question
            updatedQuestion.responsesFromSubcollection = responses
            
            return updatedQuestion
        } catch {
            print("‚ùå DailyQuestionService: Erreur chargement r√©ponses - \(error)")
            return question
        }
    }
    
    // NOUVEAU: √âcouter les changements dans les r√©ponses de la question actuelle
    private func setupResponsesListener(for question: DailyQuestion) async {
        responsesListener?.remove()
        
        responsesListener = db.collection("dailyQuestions")
            .document(question.id)
            .collection("responses")
            .order(by: "respondedAt")
            .addSnapshotListener { [weak self] snapshot, error in
                Task { @MainActor in
                if let error = error {
                        print("‚ùå DailyQuestionService: Erreur listener r√©ponses - \(error)")
                    return
                }
                
                    guard let documents = snapshot?.documents else { return }
                    
                    var responses: [QuestionResponse] = []
                    for document in documents {
                        if let response = try? document.data(as: QuestionResponse.self) {
                            responses.append(response)
                        }
                    }
                    
                    // Mettre √† jour la question actuelle avec les nouvelles r√©ponses
                    if var currentQuestion = self?.currentQuestion, currentQuestion.id == question.id {
                        let previousResponsesCount = currentQuestion.responsesFromSubcollection.count
                        currentQuestion.responsesFromSubcollection = responses
                        self?.currentQuestion = currentQuestion
                        
                        // Mettre √† jour aussi dans l'historique
                        if let index = self?.questionHistory.firstIndex(where: { $0.id == question.id }) {
                            self?.questionHistory[index] = currentQuestion
                        }
                        
                        print("‚úÖ DailyQuestionService: R√©ponses mises √† jour - \(responses.count) r√©ponses")
                        
                        // NOUVEAU: Notifier si nouvelles r√©ponses d√©tect√©es
                        if responses.count > previousResponsesCount,
                           let newResponse = responses.last {
                            await self?.scheduleNewMessageNotification(for: currentQuestion, newResponse: newResponse)
                        }
                        
                        // Mettre √† jour notification apr√®s changement de r√©ponses
                        await self?.scheduleDailyQuestionReminder(for: currentQuestion)
                    }
                }
            }
    }
    
    // MARK: - Computed Properties
    
    var coupleId: String? {
        guard let currentUser = Auth.auth().currentUser,
              let appUser = appState?.currentUser,
              let partnerId = appUser.partnerId,
              !partnerId.isEmpty else {
            return nil
        }
        
        return [currentUser.uid, partnerId].sorted().joined(separator: "_")
    }
    
    // MARK: - Actions publiques
    
    func generateTodaysQuestion() async {
        guard let currentUser = Auth.auth().currentUser,
              let coupleId = coupleId else {
            print("‚ùå DailyQuestionService: Pas d'utilisateur connect√©")
            return
        }
        
        print("üöÄ DailyQuestionService: D√©but g√©n√©ration question pour couple: \(coupleId)")

        // NOUVEAU: Bloquer si pas de settings disponibles
        guard let settings = currentSettings else {
            print("‚öôÔ∏è DailyQuestionService: Pas encore de settings ‚Äì on attend le listener")
            return
        }
        
        print("‚öôÔ∏è SETTINGS CHARG√âS:")
        print("‚öôÔ∏è - startDate: \(settings.startDate)")
        print("‚öôÔ∏è - currentDay: \(settings.currentDay)")
        print("‚öôÔ∏è - timezone: \(settings.timezone)")

        // V√©rifier si une nouvelle question doit r√©ellement √™tre g√©n√©r√©e (apr√®s 21h)
        if DailyQuestionGenerator.shouldShowNewQuestion(settings: settings) == false {
            print("‚ÑπÔ∏è DailyQuestionService: Pas encore l'heure de la nouvelle question ‚Äì g√©n√©ration annul√©e")
            return
        }
        
        isLoading = true
        defer { isLoading = false }

        do {
            // Calculer le jour attendu bas√© sur le temps √©coul√©
            let expectedDay = DailyQuestionGenerator.calculateCurrentQuestionDay(for: coupleId, settings: settings) ?? settings.currentDay
            
            print("‚öôÔ∏è CALCUL EXPECTEDDAY:")
            print("‚öôÔ∏è - expectedDay calcul√©: \(expectedDay)")
            print("‚öôÔ∏è - settings.currentDay: \(settings.currentDay)")
            
            // CORRECTION TIMEZONE: Utiliser UTC pour √©viter les probl√®mes startOfDay
            var calendar = Calendar(identifier: .gregorian)
            calendar.timeZone = TimeZone(identifier: "UTC")!
            let startOfDay = calendar.startOfDay(for: settings.startDate)
            let startOfToday = calendar.startOfDay(for: Date())
            let daysSinceStart = calendar.dateComponents([.day], from: startOfDay, to: startOfToday).day ?? 0
            
            print("‚öôÔ∏è DATES (UTC FIXED):")
            print("‚öôÔ∏è - startOfDay: \(startOfDay)")
            print("‚öôÔ∏è - startOfToday: \(startOfToday)")
            print("‚öôÔ∏è - daysSinceStart: \(daysSinceStart)")
            
            print("üåê APPEL CLOUD FUNCTION:")
            print("üåê - coupleId: \(coupleId)")
            print("üåê - userId: \(currentUser.uid)")
            print("üåê - questionDay: \(expectedDay)")
            print("üåê - timezone: \(TimeZone.current.identifier)")
            
            let result = try await functions.httpsCallable("generateDailyQuestion").call([
                "coupleId": coupleId,
                "userId": currentUser.uid,
                "questionDay": expectedDay,
                "timezone": TimeZone.current.identifier
            ])

            print("üì• R√âPONSE CLOUD FUNCTION:")
            
            if let data = result.data as? [String: Any],
               let success = data["success"] as? Bool,
               success {
                    print("‚úÖ Question g√©n√©r√©e avec succ√®s")
                
                if let questionData = data["question"] as? [String: Any] {
                    let questionKey = questionData["questionKey"] as? String ?? "inconnu"
                    let questionDay = questionData["questionDay"] as? Int ?? 0
                    print("‚öôÔ∏è - questionKey re√ßue: \(questionKey)")
                    print("‚öôÔ∏è - questionDay retourn√©: \(questionDay)")
                }
                
                // Mettre √† jour le jour courant vers le jour attendu
                if var settings = self.currentSettings {
                    settings.currentDay = expectedDay
                    self.currentSettings = settings
                    print("‚öôÔ∏è Settings mis √† jour localement - currentDay: \(expectedDay)")

                    // Mettre √† jour Firestore pour persister le nouveau currentDay
                    if let coupleId = self.coupleId {
                        do {
                            try await db.collection("dailyQuestionSettings")
                                .document(coupleId)
                                .updateData(["currentDay": settings.currentDay,
                                             "lastVisitDate": Timestamp(date: Date())])
                            print("‚úÖ DailyQuestionService: currentDay mis √† jour ‚Üí \(settings.currentDay)")
                        } catch {
                            print("‚ùå DailyQuestionService: Impossible de mettre √† jour currentDay - \(error)")
                        }
                    }
                }

                if let exhausted = data["allQuestionsExhausted"] as? Bool, exhausted {
                    allQuestionsExhausted = true
                    }
                } else {
                    print("‚ùå DailyQuestionService: √âchec g√©n√©ration question")
            }
        } catch {
            print("‚ùå DailyQuestionService: Erreur g√©n√©ration - \(error)")
        }
    }
    
    // NOUVEAU: Soumettre une r√©ponse via le syst√®me de sous-collections
    func submitResponse(_ responseText: String) async -> Bool {
        guard let currentUser = Auth.auth().currentUser,
              let userName = appState?.currentUser?.name,
              let question = currentQuestion else {
            print("‚ùå DailyQuestionService: Donn√©es manquantes pour la r√©ponse")
            return false
        }
        
        print("üî• DailyQuestionService: Soumission r√©ponse:")
        print("   - Question ID: \(question.id)")
        print("   - Utilisateur: \(currentUser.uid)")
        print("   - Nom: \(userName)")
        print("   - Texte: '\(responseText)'")
        print("üî• DailyQuestionService: Cette action devrait d√©clencher notifyPartnerResponseSubcollection")
        
        do {
            let result = try await functions.httpsCallable("submitDailyQuestionResponse").call([
                "questionId": question.id,
                "responseText": responseText,
                "userName": userName
            ])
            
            if let data = result.data as? [String: Any],
               let success = data["success"] as? Bool,
               success {
            print("‚úÖ DailyQuestionService: R√©ponse soumise avec succ√®s")
            print("üì® DailyQuestionService: Cloud Function devrait envoyer push au partenaire maintenant")
            return true
            } else {
                print("‚ùå DailyQuestionService: √âchec soumission r√©ponse")
                if let data = result.data as? [String: Any],
                   let message = data["message"] as? String {
                    print("‚ùå DailyQuestionService: Message: \(message)")
                }
                return false
            }
        } catch {
            print("‚ùå DailyQuestionService: Erreur soumission - \(error)")
            return false
        }
    }
    
    // MARK: - Migration Support
    
    func migrateTodaysQuestionToSubcollections() async -> Bool {
        guard let currentUser = Auth.auth().currentUser,
              let coupleId = coupleId else {
            print("‚ùå DailyQuestionService: Pas d'utilisateur connect√© pour migration")
            return false
        }
        
        do {
            let result = try await functions.httpsCallable("migrateDailyQuestionResponses").call([
                "coupleId": coupleId
            ])
            
            if let data = result.data as? [String: Any],
               let success = data["success"] as? Bool,
               success {
                print("‚úÖ DailyQuestionService: Migration r√©ussie")
                return true
            } else {
                print("‚ùå DailyQuestionService: √âchec migration")
                return false
            }
        } catch {
            print("‚ùå DailyQuestionService: Erreur migration - \(error)")
            return false
        }
    }
    
    // MARK: - Helpers
    
    private func scheduleDailyQuestionReminder(for question: DailyQuestion) async {
        // NOUVEAU: Ne programmer que si L'UTILISATEUR ACTUEL n'a pas r√©pondu
        // (peu importe si le partenaire a r√©pondu ou non)
        guard let currentUserId = Auth.auth().currentUser?.uid,
              question.currentUserResponse == nil else {
            print("üîî DailyQuestionService: L'utilisateur actuel a d√©j√† r√©pondu ‚Äì pas de notification √† programmer")
            UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: ["daily_question_reminder_\(question.id)"])
            return
        }
        
        let center = UNUserNotificationCenter.current()
        let identifier = "daily_question_reminder_\(question.id)"
        
        // Toujours nettoyer d'abord
        center.removePendingNotificationRequests(withIdentifiers: [identifier])
        
        // Calculer 21h locale aujourd'hui
        var components = Calendar.current.dateComponents([.year, .month, .day], from: Date())
        components.hour = 21
        components.minute = 0
        components.second = 0
        guard let today21h = Calendar.current.date(from: components) else { return }
        let fireDate: Date
        if today21h > Date() {
            fireDate = today21h
        } else {
            fireDate = Calendar.current.date(byAdding: .day, value: 1, to: today21h) ?? today21h
        }
        
        // Construire le trigger calendrier
        let triggerComponents = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second], from: fireDate)
        let trigger = UNCalendarNotificationTrigger(dateMatching: triggerComponents, repeats: false)
        
        let content = UNMutableNotificationContent()
        content.title = NSLocalizedString("daily_question_notification_title", tableName: "DailyQuestions", comment: "")
        // Corps personnalis√© si disponible dans .xcstrings sinon fallback
        let localizedBodyKey = "\(question.questionKey)_notification"
        let bodyLocalized = NSLocalizedString(localizedBodyKey, tableName: "DailyQuestions", comment: "")
        content.body = bodyLocalized == localizedBodyKey ? question.localizedText : bodyLocalized
        content.sound = .default
        content.badge = 1
        
        print("üîî DailyQuestionService: Programmation notification locale:")
        print("   - ID: \(identifier)")
        print("   - Date: \(fireDate)")
        print("   - Title: \(content.title)")
        print("   - Body: \(content.body)")
        
        let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)
        do {
            try await center.add(request)
            print("‚úÖ DailyQuestionService: Notification quotidienne programm√©e avec succ√®s")
        } catch {
            print("‚ùå DailyQuestionService: Erreur programmation notification - \(error)")
        }
    }
    
    // MARK: - Notifications pour nouveaux messages
    
    private func scheduleNewMessageNotification(for question: DailyQuestion, newResponse: QuestionResponse) async {
        // Ne notifier que si le message vient du partenaire
        guard let currentUserId = Auth.auth().currentUser?.uid,
              newResponse.userId != currentUserId else {
            print("üîî DailyQuestionService: Message de l'utilisateur actuel ‚Äì pas de notification")
            return
        }
        
        let center = UNUserNotificationCenter.current()
        let identifier = "new_message_\(question.id)_\(newResponse.id)"
        
        let content = UNMutableNotificationContent()
        content.title = NSLocalizedString("daily_question_notification_title", tableName: "DailyQuestions", comment: "")
        content.body = "üí¨ \(newResponse.userName): \(String(newResponse.text.prefix(50)))\(newResponse.text.count > 50 ? "..." : "")"
        content.sound = .default
        content.badge = 1
        
        // Notification imm√©diate pour nouveau message
        let request = UNNotificationRequest(identifier: identifier, content: content, trigger: nil)
        
        print("üîî DailyQuestionService: Programmation notification nouveau message:")
        print("   - ID: \(identifier)")
        print("   - De: \(newResponse.userName)")
        print("   - Preview: \(String(newResponse.text.prefix(30)))...")
        
        do {
            try await center.add(request)
            print("‚úÖ DailyQuestionService: Notification nouveau message programm√©e")
        } catch {
            print("‚ùå DailyQuestionService: Erreur notification nouveau message - \(error)")
        }
    }
    
    
    /// CORRECTION TEMPORAIRE : Corriger les settings de questions quotidiennes
    func fixDailyQuestionSettings() async {
        guard let currentUser = Auth.auth().currentUser,
              let coupleId = coupleId else {
            print("‚ùå DailyQuestionService: Pas d'utilisateur pour correction")
            return
        }
        
        print("üîß DailyQuestionService: Correction des settings...")
        
        do {
            let result = try await functions.httpsCallable("fixDailyQuestionSettings").call([
                "coupleId": coupleId
            ])
            
            if let data = result.data as? [String: Any],
               let success = data["success"] as? Bool,
               success {
                print("‚úÖ DailyQuestionService: Settings corrig√©s avec succ√®s")
                print("‚úÖ Message: \(data["message"] as? String ?? "")")
                
                // Recharger les settings apr√®s correction
                if let currentCoupleId = self.coupleId {
                    setupSettingsListener(for: currentCoupleId)
                }
                
                // Reg√©n√©rer la question d'aujourd'hui
                await generateTodaysQuestion()
            } else {
                print("‚ùå DailyQuestionService: √âchec correction settings")
            }
        } catch {
            print("‚ùå DailyQuestionService: Erreur correction - \(error)")
        }
    }
    
    // NOUVEAU: Chargement depuis le cache Realm en cas de probl√®me Firestore
    private func loadFromRealmCache(coupleId: String) async {
        print("üîÑ DailyQuestionService: Chargement depuis le cache Realm pour couple: \(coupleId)")
        
        let cachedQuestions = QuestionCacheManager.shared.getCachedDailyQuestions(for: coupleId, limit: 10)
        
        print("üì¶ DailyQuestionService: \(cachedQuestions.count) questions trouv√©es dans le cache Realm")
        
        // Logs d√©taill√©s des questions en cache
        for (index, question) in cachedQuestions.enumerated() {
            print("üìù Cache \(index + 1): questionKey=\(question.questionKey), day=\(question.questionDay), date=\(question.scheduledDate)")
        }
        
        if !cachedQuestions.isEmpty {
            self.questionHistory = cachedQuestions
            self.currentQuestion = cachedQuestions.first
            
            print("‚úÖ DailyQuestionService: \(cachedQuestions.count) questions charg√©es depuis le cache")
            
            if let current = cachedQuestions.first {
                print("üéØ DailyQuestionService: Question actuelle charg√©e depuis le cache:")
                print("   - questionKey: \(current.questionKey)")
                print("   - questionDay: \(current.questionDay)")
                print("   - scheduledDate: \(current.scheduledDate)")
            }
        } else {
            print("‚ùå DailyQuestionService: Aucune question trouv√©e dans le cache")
        }
    }
    
    func shouldAutoMigrate() -> Bool {
        // Auto-migrer si on d√©tecte l'ancien format
        return currentQuestion?.shouldUseLegacyMode == true
    }
    
    func refreshCurrentQuestion() async {
        // Forcer un refresh des donn√©es
        setupListeners()
    }
    
    func loadQuestionHistory() async {
        // Pour les statistiques seulement : charger l'historique r√©cent
        guard let coupleId = coupleId else {
            print("‚ùå DailyQuestionService: Pas de coupleId pour l'historique")
            return
        }
        
        do {
            let snapshot = try await db.collection("dailyQuestions")
                .whereField("coupleId", isEqualTo: coupleId)
                .order(by: "scheduledDate", descending: true)
                .limit(to: 30) // Seulement les 30 derni√®res pour les stats
                .getDocuments()
            
            var questions: [DailyQuestion] = []
            
            for document in snapshot.documents {
                do {
                    var question = try document.data(as: DailyQuestion.self)
                    question = await loadResponsesForQuestion(question)
                    questions.append(question)
                } catch {
                    print("‚ùå DailyQuestionService: Erreur d√©codage question historique - \(error)")
                }
            }
            
            questionHistory = questions
            print("üìä DailyQuestionService: \(questions.count) questions charg√©es pour statistiques")
        } catch {
            print("‚ùå DailyQuestionService: Erreur chargement historique - \(error)")
        }
    }
}

// MARK: - Extensions pour DailyQuestion

extension DailyQuestion {
    func getCurrentUserResponse(userId: String) -> QuestionResponse? {
        return responses[userId]
    }
    
    func getPartnerResponse(excluding userId: String) -> QuestionResponse? {
        return responses.values.first { $0.userId != userId }
    }
    
    func canUserRespond(userId: String) -> Bool {
        let userResponse = responses[userId]
        return userResponse?.status != .answered && !isExpired
    }
    
    func shouldShowWaitingMessage(for userId: String) -> Bool {
        let userResponse = responses[userId]
        return userResponse?.status == .answered && !bothResponded
    }
} 