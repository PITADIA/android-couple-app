package com.love2loveapp.services.cache

import android.content.Context
import android.content.SharedPreferences
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.util.Base64
import android.util.Log
import com.google.gson.Gson
import java.io.ByteArrayOutputStream
import java.util.Date
import com.love2loveapp.model.AppConstants

/**
 * √âquivalent Kotlin/Android du UserCacheManager (Swift).
 *
 * ‚úÖ JSON de l'utilisateur en SharedPreferences (Gson)
 * ‚úÖ Images de profil & partenaire en Base64 (JPEG, qualit√© 0.8) dans SharedPreferences
 * ‚úÖ TTL du cache utilisateur : 7 jours
 * ‚úÖ Helpers: hasCache, clearCache, updateCachedUser (transform)
 *
 * ‚ö†Ô∏è Remarque performance: pour des images lourdes, pr√©f√©rer un cache disque (ex: fichiers dans cacheDir)
 *    ou une lib (Coil/Glide). Cette impl√©mentation reste 1:1 avec l‚Äôapproche UserDefaults de la version iOS.
 *
 * Utilisation :
 *   UserCacheManager.init(appContext)
 *   UserCacheManager.cacheUser(user)
 *   val cached = UserCacheManager.getCachedUser()
 */
object UserCacheManager {

    private const val TAG = "UserCacheManager"
    private const val PREFS_NAME = "cached_user_prefs"

    // Keys
    private const val KEY_USER_JSON = "cached_user_data"
    private const val KEY_USER_TS = "cached_user_timestamp"
    private const val KEY_PROFILE_IMG = "cached_profile_image"
    private const val KEY_PARTNER_IMG = "cached_partner_image"
    private const val KEY_PARTNER_IMG_URL = "cached_partner_image_url"

    // TTL 7 jours
    private const val CACHE_MAX_AGE_MS = AppConstants.Cache.USER_CACHE_MAX_AGE_MS

    private lateinit var prefs: SharedPreferences
    private val gson by lazy { Gson() }

    @Volatile private var initialized = false

    /** √Ä appeler une seule fois (ex: dans Application.onCreate()) */
    fun init(context: Context) {
        if (!initialized) {
            synchronized(this) {
                if (!initialized) {
                    prefs = context.applicationContext.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
                    initialized = true
                    Log.d(TAG, "‚úÖ init: SharedPreferences initialis√©s")
                }
            }
        }
    }

    // --- S√©curit√© interne ---
    private fun requireInit() {
        check(initialized) { "UserCacheManager.init(context) doit √™tre appel√© avant usage." }
    }

    // ============
    // USER CACHE
    // ============

    /** Cache l'utilisateur apr√®s chargement Firebase */
    fun cacheUser(user: AppUser) {
        requireInit()
        return try {
            Log.d(TAG, "üíæ Mise en cache utilisateur: ${user.name}")
            val json = gson.toJson(user)
            prefs.edit()
                .putString(KEY_USER_JSON, json)
                .putLong(KEY_USER_TS, System.currentTimeMillis())
                .apply()
            Log.d(TAG, "‚úÖ Utilisateur mis en cache avec succ√®s")
        } catch (t: Throwable) {
            Log.e(TAG, "‚ùå Erreur encodage utilisateur: ${t.message}", t)
        }
    }

    /** R√©cup√®re l'utilisateur en cache (instantan√©, TTL 7j) */
    fun getCachedUser(): AppUser? {
        requireInit()
        val json = prefs.getString(KEY_USER_JSON, null) ?: run {
            Log.d(TAG, "üìÇ Aucun utilisateur en cache")
            return null
        }

        // V√©rifier l'√¢ge du cache
        prefs.getLong(KEY_USER_TS, 0L).let { ts ->
            if (ts > 0) {
                val age = System.currentTimeMillis() - ts
                if (age > CACHE_MAX_AGE_MS) {
                    Log.d(TAG, "‚è∞ Cache expir√© (${age / 3600000}h), nettoyage")
                    clearCache()
                    return null
                }
            }
        }

        return try {
            val user = gson.fromJson(json, AppUser::class.java)
            Log.d(TAG, "üöÄ Utilisateur trouv√© en cache: ${user.name}")
            user
        } catch (t: Throwable) {
            Log.e(TAG, "‚ùå Erreur d√©codage cache: ${t.message}. Nettoyage‚Ä¶", t)
            clearCache()
            null
        }
    }

    /** V√©rifie si un utilisateur est en cache */
    fun hasCachedUser(): Boolean {
        requireInit()
        return prefs.contains(KEY_USER_JSON)
    }

    /** Nettoie le cache (d√©connexion, suppression compte, etc.) */
    fun clearCache() {
        requireInit()
        Log.d(TAG, "üóëÔ∏è Nettoyage cache utilisateur")
        prefs.edit()
            .remove(KEY_USER_JSON)
            .remove(KEY_USER_TS)
            .apply()
        clearCachedProfileImage()
        clearCachedPartnerImage()
    }

    // =================
    // PROFILE IMAGE
    // =================

    /** Cache l'image de profil (JPEG 80%) */
    fun cacheProfileImage(bitmap: Bitmap) {
        requireInit()
        try {
            Log.d(TAG, "üñºÔ∏è Mise en cache image de profil")
            val bytes = bitmap.toJpegBytes(quality = AppConstants.Cache.IMAGE_CACHE_QUALITY)
            prefs.edit().putString(KEY_PROFILE_IMG, bytes.base64()).apply()
            Log.d(TAG, "‚úÖ Image de profil mise en cache (${bytes.size} bytes)")
        } catch (t: Throwable) {
            Log.e(TAG, "‚ùå Impossible de convertir l'image de profil: ${t.message}", t)
        }
    }

    /** R√©cup√®re l'image de profil en cache */
    fun getCachedProfileImage(): Bitmap? {
        requireInit()
        val b64 = prefs.getString(KEY_PROFILE_IMG, null) ?: run {
            Log.d(TAG, "üñºÔ∏è Aucune image de profil en cache")
            return null
        }
        return try {
            val bytes = Base64.decode(b64, Base64.DEFAULT)
            BitmapFactory.decodeByteArray(bytes, 0, bytes.size) ?: run {
                Log.e(TAG, "‚ùå Decode image profil √©chou√©, nettoyage cl√©")
                prefs.edit().remove(KEY_PROFILE_IMG).apply()
                null
            }.also {
                if (it != null) Log.d(TAG, "‚úÖ Image de profil trouv√©e en cache")
            }
        } catch (t: Throwable) {
            Log.e(TAG, "‚ùå Erreur chargement image profil: ${t.message}", t)
            prefs.edit().remove(KEY_PROFILE_IMG).apply()
            null
        }
    }

    /** Pr√©sence image de profil */
    fun hasCachedProfileImage(): Boolean {
        requireInit()
        return prefs.contains(KEY_PROFILE_IMG)
    }

    /** Nettoie seulement l'image de profil en cache */
    fun clearCachedProfileImage() {
        requireInit()
        Log.d(TAG, "üóëÔ∏è Nettoyage image de profil en cache")
        prefs.edit().remove(KEY_PROFILE_IMG).apply()
    }

    // =================
    // PARTNER IMAGE
    // =================

    /** Cache l'image du partenaire + son URL source (pour d√©tection de changement) */
    fun cachePartnerImage(bitmap: Bitmap, url: String) {
        requireInit()
        try {
            Log.d(TAG, "ü§ù Mise en cache image partenaire")
            val bytes = bitmap.toJpegBytes(quality = AppConstants.Cache.IMAGE_CACHE_QUALITY)
            prefs.edit()
                .putString(KEY_PARTNER_IMG, bytes.base64())
                .putString(KEY_PARTNER_IMG_URL, url)
                .apply()
            Log.d(TAG, "‚úÖ Image partenaire mise en cache (${bytes.size} bytes)")
        } catch (t: Throwable) {
            Log.e(TAG, "‚ùå Impossible de convertir l'image partenaire: ${t.message}", t)
        }
    }

    /** R√©cup√®re l'image partenaire en cache */
    fun getCachedPartnerImage(): Bitmap? {
        requireInit()
        val b64 = prefs.getString(KEY_PARTNER_IMG, null) ?: run {
            Log.d(TAG, "ü§ù Aucune image partenaire en cache")
            return null
        }
        return try {
            val bytes = Base64.decode(b64, Base64.DEFAULT)
            BitmapFactory.decodeByteArray(bytes, 0, bytes.size) ?: run {
                Log.e(TAG, "‚ùå Decode image partenaire √©chou√©, nettoyage cl√©s")
                clearCachedPartnerImage()
                null
            }.also {
                if (it != null) Log.d(TAG, "‚úÖ Image partenaire trouv√©e en cache")
            }
        } catch (t: Throwable) {
            Log.e(TAG, "‚ùå Erreur chargement image partenaire: ${t.message}", t)
            clearCachedPartnerImage()
            null
        }
    }

    /** V√©rifie si l‚ÄôURL partenaire a chang√© (pour d√©cider si on recharge) */
    fun hasPartnerImageChanged(newURL: String?): Boolean {
        requireInit()
        val cached = prefs.getString(KEY_PARTNER_IMG_URL, null)
        val changed = cached != newURL
        if (changed) Log.d(TAG, "üîÑ URL partenaire chang√©e")
        else Log.d(TAG, "‚úÖ URL partenaire inchang√©e")
        return changed
    }

    /** Pr√©sence image partenaire */
    fun hasCachedPartnerImage(): Boolean {
        requireInit()
        return prefs.contains(KEY_PARTNER_IMG)
    }

    /** Nettoie l‚Äôimage partenaire */
    fun clearCachedPartnerImage() {
        requireInit()
        Log.d(TAG, "üóëÔ∏è Nettoyage image partenaire en cache")
        prefs.edit()
            .remove(KEY_PARTNER_IMG)
            .remove(KEY_PARTNER_IMG_URL)
            .apply()
    }

    // ==========================
    // UPDATE PARTIEL UTILISATEUR
    // ==========================

    /**
     * Met √† jour l‚Äôutilisateur en cache via une transformation immuable.
     * Exemple :
     *   UserCacheManager.updateCachedUser { it.copy(name = "Nouveau nom") }
     */
    fun updateCachedUser(transform: (AppUser) -> AppUser) {
        requireInit()
        val current = getCachedUser()
        if (current == null) {
            Log.w(TAG, "‚ö†Ô∏è Impossible de mettre √† jour - pas d'utilisateur en cache")
            return
        }
        val updated = try {
            transform(current)
        } catch (t: Throwable) {
            Log.e(TAG, "‚ùå Erreur transform utilisateur: ${t.message}", t)
            return
        }
        cacheUser(updated)
    }

    // ===========
    // INFO CACHE
    // ===========

    data class CacheInfo(
        val hasCache: Boolean,
        val lastUpdated: Date?,
        val userCount: Int
    )

    fun getCacheInfo(): CacheInfo {
        requireInit()
        val hasCache = hasCachedUser()
        val ts = prefs.getLong(KEY_USER_TS, 0L)
        val lastUpdated = if (ts > 0) Date(ts) else null
        return CacheInfo(hasCache, lastUpdated, if (hasCache) 1 else 0)
    }

    // ====================
    // Helpers internes
    // ====================

    private fun Bitmap.toJpegBytes(quality: Int = 80): ByteArray {
        val bos = ByteArrayOutputStream()
        this.compress(Bitmap.CompressFormat.JPEG, quality.coerceIn(0, 100), bos)
        return bos.toByteArray()
    }

    private fun ByteArray.base64(): String =
        Base64.encodeToString(this, Base64.DEFAULT)
}

/**
 * Ton mod√®le Kotlin doit √™tre s√©rialisable par Gson.
 * Exemple minimal :
 *
 * data class AppUser(
 *   val id: String,
 *   val name: String,
 *   val email: String? = null,
 *   // ... autres champs (doivent rester compatibles JSON)
 * )
 */
data class AppUser(
    val id: String,
    val name: String,
    val email: String? = null
    // ajoute ici les champs dont tu as besoin
)
