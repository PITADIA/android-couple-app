import Foundation
import FirebaseFirestore
import FirebaseAuth
import FirebaseFunctions
import Combine
import FirebaseAnalytics

class PartnerCodeService: ObservableObject {
    static let shared = PartnerCodeService()
    
    private let db = Firestore.firestore()
    
    @Published var generatedCode: String?
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var isConnected = false
    @Published var partnerInfo: PartnerInfo?
    
    struct PartnerInfo {
        let id: String
        let name: String
        let connectedAt: Date
        let isSubscribed: Bool
    }
    
    private init() {}
    
    // MARK: - G√©n√©ration d'un code partenaire temporaire (conforme Apple)
    
    func generatePartnerCode() async -> String? {
        print("üîó PartnerCodeService: D√©but g√©n√©ration code")
        
        guard let currentUser = Auth.auth().currentUser else {
            print("‚ùå PartnerCodeService: Utilisateur non connect√©")
            await MainActor.run {
                self.errorMessage = NSLocalizedString("user_not_connected", comment: "User not connected error")
            }
            return nil
        }
        
        print("üîó PartnerCodeService: Utilisateur connect√©")
        
        await MainActor.run {
            self.isLoading = true
            self.errorMessage = nil
        }
        
        // üõ°Ô∏è CONFORMIT√â APPLE : V√©rifier si l'utilisateur a un code r√©cent (< 24h)
        do {
            print("üîó PartnerCodeService: V√©rification code r√©cent (< 24h)...")
            
            let yesterday = Date().addingTimeInterval(-86400) // 24h en secondes
            let recentCodeSnapshot = try await db.collection("partnerCodes")
                .whereField("userId", isEqualTo: currentUser.uid)
                .whereField("createdAt", isGreaterThan: Timestamp(date: yesterday))
                .whereField("isActive", isEqualTo: true)
                .getDocuments()
            
            print("üîó PartnerCodeService: Nombre de codes r√©cents trouv√©s: \(recentCodeSnapshot.documents.count)")
            
            // Si un code r√©cent existe (< 24h), le retourner
            if let existingDoc = recentCodeSnapshot.documents.first {
                let existingCode = existingDoc.documentID
                print("üîó PartnerCodeService: Code r√©cent trouv√©: \(existingCode)")
                await MainActor.run {
                    self.generatedCode = existingCode
                    self.isLoading = false
                }
                print("‚úÖ PartnerCodeService: Code r√©cent retourn√© et UI mise √† jour")
                return existingCode
            }
            
            // üîÑ MIGRATION PROGRESSIVE : V√©rifier codes anciens (sans expiresAt)
            print("üîó PartnerCodeService: V√©rification codes legacy...")
            let legacyCodeSnapshot = try await db.collection("partnerCodes")
                .whereField("userId", isEqualTo: currentUser.uid)
                .whereField("isActive", isEqualTo: true)
                .getDocuments()
            
            // Si code legacy existe, lui donner 72h de gr√¢ce (migration douce)
            if let legacyDoc = legacyCodeSnapshot.documents.first {
                let legacyData = legacyDoc.data()
                
                // Si pas d'expiresAt, c'est un ancien code
                if legacyData["expiresAt"] == nil {
                    let gracePeriod = Date().addingTimeInterval(259200) // 72h de gr√¢ce
                    
                    // Migrer vers le nouveau format avec p√©riode de gr√¢ce
                    try await legacyDoc.reference.updateData([
                        "expiresAt": Timestamp(date: gracePeriod),
                        "migrationGracePeriod": true,
                        "rotationReason": "apple_compliance_migration"
                    ])
                    
                    print("üîÑ PartnerCodeService: Code legacy migr√© avec 72h de gr√¢ce")
                    
                    await MainActor.run {
                        self.generatedCode = legacyDoc.documentID
                        self.isLoading = false
                    }
                    return legacyDoc.documentID
                }
            }
            
            // üîÑ ROTATION : D√©sactiver uniquement les anciens codes non-legacy
            print("üîó PartnerCodeService: D√©sactivation codes expir√©s...")
            for document in legacyCodeSnapshot.documents {
                let data = document.data()
                if let expiresAt = data["expiresAt"] as? Timestamp,
                   expiresAt.dateValue() < Date() {
                    try await document.reference.updateData(["isActive": false])
                }
            }
            
            print("üîó PartnerCodeService: Aucun code existant, g√©n√©ration d'un nouveau...")
            
            // G√©n√©rer un nouveau code unique
            var code: String
            var isUnique = false
            var attempts = 0
            
            repeat {
                code = String(format: "%08d", Int.random(in: 10000000...99999999))
                print("üîó PartnerCodeService: Tentative \(attempts + 1) - Code g√©n√©r√©: \(code)")
                
                // V√©rifier si le code existe d√©j√†
                let existingDoc = try await db.collection("partnerCodes").document(code).getDocument()
                isUnique = !existingDoc.exists
                attempts += 1
                
                print("üîó PartnerCodeService: Code \(code) unique: \(isUnique)")
                
                if attempts > 10 {
                    print("‚ùå PartnerCodeService: Trop de tentatives, abandon")
                    await MainActor.run {
                        self.errorMessage = "Erreur lors de la g√©n√©ration du code"
                        self.isLoading = false
                    }
                    return nil
                }
            } while !isUnique
            
            print("üîó PartnerCodeService: Code unique trouv√©: \(code), cr√©ation en base...")
            
            // üõ°Ô∏è CONFORMIT√â APPLE : Cr√©er le nouveau code TEMPORAIRE (24h)
            try await db.collection("partnerCodes").document(code).setData([
                "userId": currentUser.uid,
                "createdAt": Timestamp(date: Date()),
                "expiresAt": Timestamp(date: Date().addingTimeInterval(86400)), // 24h
                "isActive": true,
                "connectedPartnerId": NSNull(), // Pas encore connect√©
                "rotationReason": "apple_compliance" // Justification rotation
            ])
            
            print("‚úÖ PartnerCodeService: Code cr√©√© en base avec succ√®s")
            
            let capturedCode = code
            await MainActor.run {
                self.generatedCode = capturedCode
                self.isLoading = false
            }
            
            print("‚úÖ PartnerCodeService: Nouveau code g√©n√©r√© et UI mise √† jour: \(code)")
            return code
            
        } catch {
            print("‚ùå PartnerCodeService: Erreur g√©n√©ration code: \(error)")
            print("‚ùå PartnerCodeService: D√©tails erreur: \(error.localizedDescription)")
            await MainActor.run {
                self.errorMessage = "Erreur lors de la g√©n√©ration du code: \(error.localizedDescription)"
                self.isLoading = false
            }
            return nil
        }
    }
    
    // MARK: - Connexion avec un code partenaire
    
    func connectWithPartnerCode(
        _ code: String, 
        context: ConnectionConfig.ConnectionContext = .onboarding
    ) async -> Bool {
        print("üîó PartnerCodeService: connectWithPartnerCode - Code: \(code) - Context: \(context.rawValue)")
        
        // Analytics: Track connection start
        AnalyticsService.shared.track(.connectStart(source: context.rawValue))
        
        guard let currentUser = Auth.auth().currentUser else {
            print("‚ùå PartnerCodeService: Utilisateur non connect√©")
            await MainActor.run {
                self.errorMessage = "Utilisateur non connect√©"
            }
            return false
        }
        
        print("üîó PartnerCodeService: Utilisateur connect√©")
        
        await MainActor.run {
            self.isLoading = true
            self.errorMessage = nil
        }
        
        do {
            // Connexion s√©curis√©e c√¥t√© serveur
            print("üîó PartnerCodeService: Connexion s√©curis√©e via Cloud Function...")
            let functions = Functions.functions()
            let connectFunction = functions.httpsCallable("connectPartners")
            
            let result = try await connectFunction.call(["partnerCode": code])
            guard let data = result.data as? [String: Any] else {
                print("‚ùå PartnerCodeService: R√©ponse de connexion invalide")
                await MainActor.run {
                    self.errorMessage = NSLocalizedString("connection_error", comment: "Connection error")
                    self.isLoading = false
                }
                return false
            }
            
            guard let success = data["success"] as? Bool, success else {
                print("‚ùå PartnerCodeService: Connexion √©chou√©e")
                await MainActor.run {
                    self.errorMessage = NSLocalizedString("connection_error", comment: "Connection error")
                    self.isLoading = false
                }
                return false
            }
            
            let partnerName = data["partnerName"] as? String ?? "Partenaire"
            let subscriptionInherited = data["subscriptionInherited"] as? Bool ?? false
            let _ = data["message"] as? String ?? "Connexion r√©ussie"
            
            print("‚úÖ PartnerCodeService: Connexion r√©ussie - Partenaire: \(partnerName)")
            print("‚úÖ PartnerCodeService: Abonnement h√©rit√©: \(subscriptionInherited)")
            
            // üìä Analytics: Partenaire connect√©
            Analytics.logEvent("partenaire_connecte", parameters: [:])
            print("üìä √âv√©nement Firebase: partenaire_connecte")
            
            // Plus besoin de tracker la connexion partenaire pour les reviews
            
            // Mettre √† jour l'interface utilisateur
            await MainActor.run {
                self.isConnected = true
                self.partnerInfo = PartnerInfo(
                    id: "", // Sera mis √† jour par les listeners
                    name: partnerName,
                    connectedAt: Date(),
                    isSubscribed: subscriptionInherited
                )
                self.isLoading = false
                
                // Afficher un message de succ√®s personnalis√©
                if subscriptionInherited {
                    print("üéâ PartnerCodeService: Abonnement premium d√©bloqu√© !")
                }
            }
            
            // NOUVEAU: Forcer le rechargement imm√©diat des donn√©es utilisateur AVANT la notification
            // pour que le partnerId soit disponible pour le reset des flags
            print("üîÑ PartnerCodeService: Rechargement imm√©diat des donn√©es utilisateur")
            FirebaseService.shared.forceRefreshUserData()
            
            // üö® FIX CRITIQUE: Reset des flags SYNCHRONIQUEMENT d√®s que partnerId confirm√©
            // (pas de d√©lai arbitraire fragile)
            if let refreshedUser = FirebaseService.shared.currentUser,
               let confirmedPartnerId = refreshedUser.partnerId,
               !confirmedPartnerId.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                
                // Reset flags imm√©diatement avec partnerId confirm√©
                resetIntroFlagsForNewCouple(partnerId: confirmedPartnerId)
                
                // Puis envoyer notifications
                notifyConnectionSuccess(
                    partnerName: partnerName, 
                    subscriptionInherited: subscriptionInherited,
                    context: context
                )
            } else {
                print("‚ùå PartnerCodeService: PartnerId pas encore disponible apr√®s refresh - fallback")
                // Fallback sur l'ancienne m√©thode si refresh pas encore termin√©
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
                    self?.notifyConnectionSuccess(
                        partnerName: partnerName, 
                        subscriptionInherited: subscriptionInherited,
                        context: context
                    )
                }
            }
            
            return true
            
        } catch {
            print("‚ùå PartnerCodeService: Erreur connexion: \(error)")
            
            // G√©rer les erreurs sp√©cifiques de Firebase Functions
            var errorMessage = "Erreur lors de la connexion"
            
            if let functionsError = error as NSError? {
                switch functionsError.code {
                case 3: // INVALID_ARGUMENT
                    errorMessage = functionsError.localizedDescription
                case 5: // NOT_FOUND
                    errorMessage = functionsError.localizedDescription
                case 6: // ALREADY_EXISTS
                    errorMessage = functionsError.localizedDescription
                case 8: // RESOURCE_EXHAUSTED
                    errorMessage = functionsError.localizedDescription
                case 9: // FAILED_PRECONDITION
                    errorMessage = functionsError.localizedDescription
                case 16: // UNAUTHENTICATED
                    errorMessage = "Vous devez √™tre connect√©"
                default:
                    errorMessage = functionsError.localizedDescription.isEmpty ? "Erreur lors de la connexion" : functionsError.localizedDescription
                }
            }
            
            let capturedErrorMessage = errorMessage
            await MainActor.run {
                self.errorMessage = capturedErrorMessage
                self.isLoading = false
            }
            return false
        }
    }
    
    // MARK: - Reset des flags d'intro
    
    private func resetIntroFlagsForNewCouple(partnerId: String) {
        guard let firebaseUID = Auth.auth().currentUser?.uid else {
            print("‚ùå PartnerCodeService: Utilisateur non connect√© pour reset flags")
            return
        }
        
        // üö® FIX CRITIQUE: Calculer coupleId avec partnerId explicite (pas d√©duit du nom)
        let newCoupleId = [firebaseUID, partnerId].sorted().joined(separator: "_")
        let oldCoupleId = UserDefaults.standard.string(forKey: "lastCoupleId")
        
        if newCoupleId != oldCoupleId {
            print("üîÑ PartnerCodeService: Nouveau couple d√©tect√©: \(oldCoupleId ?? "nil") ‚Üí \(newCoupleId)")
            
            // Reset flags en utilisant le nouveau coupleId directement
            let key = ConnectionConfig.introFlagsKey(for: newCoupleId)
            let resetFlags = IntroFlags.default
            
            if let data = try? JSONEncoder().encode(resetFlags) {
                UserDefaults.standard.set(data, forKey: key)
                print("‚úÖ PartnerCodeService: Flags reset directement pour couple: \(newCoupleId)")
            }
            
            // Sauvegarder le nouveau coupleId pour futures comparaisons
            UserDefaults.standard.set(newCoupleId, forKey: "lastCoupleId")
            
            // Forcer le rechargement des flags dans AppState sur le main thread
            DispatchQueue.main.async {
                // Pour AppState, on peut utiliser NotificationCenter pour d√©clencher le reload
                NotificationCenter.default.post(name: .introFlagsDidReset, object: nil)
                print("‚úÖ PartnerCodeService: Signal de rechargement des flags envoy√©")
            }
        } else {
            print("‚ö° PartnerCodeService: M√™me couple - Pas de reset des flags")
        }
    }
    

    
    // MARK: - Notifications de connexion r√©ussie
    
    private func notifyConnectionSuccess(
        partnerName: String, 
        subscriptionInherited: Bool,
        context: ConnectionConfig.ConnectionContext = .onboarding
    ) {
        // Analytics: Track connection success
        AnalyticsService.shared.track(.connectSuccess(
            inheritedSub: subscriptionInherited,
            context: context.rawValue
        ))
        
        // Notifier l'h√©ritage d'abonnement si applicable
        if subscriptionInherited {
            print("‚úÖ PartnerCodeService: Notification h√©ritage abonnement envoy√©e")
            NotificationCenter.default.post(name: .subscriptionInherited, object: nil)
        }
        
        // Notifier la connexion r√©ussie avec contexte
        NotificationCenter.default.post(
            name: .partnerConnected, 
            object: nil, 
            userInfo: [
                "partnerName": partnerName, 
                "isSubscribed": subscriptionInherited,
                "context": context.rawValue
            ]
        )
        
        // Aussi envoyer l'ancienne notification pour compatibilit√©
        NotificationCenter.default.post(
            name: .partnerConnectionSuccess, 
            object: nil, 
            userInfo: [
                "partnerName": partnerName, 
                "isSubscribed": subscriptionInherited,
                "context": context.rawValue
            ]
        )
        
        print("‚úÖ PartnerCodeService: Notifications de connexion envoy√©es avec contexte: \(context.rawValue)")
    }
    
    // MARK: - V√©rifier la connexion existante
    
    func checkExistingConnection() async {
        print("üîç PartnerCodeService: checkExistingConnection - D√©but v√©rification")
        guard let currentUser = Auth.auth().currentUser else { 
            print("‚ùå PartnerCodeService: checkExistingConnection - Utilisateur non connect√©")
            return 
        }
        
        do {
            print("üîç PartnerCodeService: checkExistingConnection - Chargement donn√©es utilisateur")
            let doc = try await db.collection("users").document(currentUser.uid).getDocument()
            
            if let data = doc.data(),
               let partnerId = data["partnerId"] as? String,
               !partnerId.isEmpty {
                
                print("üîç PartnerCodeService: checkExistingConnection - Partenaire trouv√©: \(partnerId)")
                
                // üîß CORRECTION: Utiliser Cloud Function pour r√©cup√©rer les infos du partenaire
                do {
                    print("üîç PartnerCodeService: checkExistingConnection - R√©cup√©ration via Cloud Function")
                    let functions = Functions.functions()
                    let result = try await functions.httpsCallable("getPartnerInfo").call([
                        "partnerId": partnerId
                    ])
                    
                    if let resultData = result.data as? [String: Any],
                       let success = resultData["success"] as? Bool,
                       success,
                       let partnerData = resultData["partnerInfo"] as? [String: Any],
                       let connectedAt = data["partnerConnectedAt"] as? Timestamp {
                        
                        let partnerName = partnerData["name"] as? String ?? "Partenaire"
                        let partnerIsSubscribed = partnerData["isSubscribed"] as? Bool ?? false
                        
                        print("‚úÖ PartnerCodeService: checkExistingConnection - Partenaire: \(partnerName), Abonn√©: \(partnerIsSubscribed)")
                        
                        await MainActor.run {
                            self.isConnected = true
                            self.partnerInfo = PartnerInfo(
                                id: partnerId,
                                name: partnerName,
                                connectedAt: connectedAt.dateValue(),
                                isSubscribed: partnerIsSubscribed
                            )
                        }
                    } else {
                        print("‚ùå PartnerCodeService: checkExistingConnection - √âchec r√©cup√©ration info partenaire")
                    }
                } catch {
                    print("‚ùå PartnerCodeService: checkExistingConnection - Erreur Cloud Function: \(error)")
                }
            } else {
                print("üîç PartnerCodeService: checkExistingConnection - Aucun partenaire connect√©")
            }
            
            // V√©rifier si l'utilisateur a un code g√©n√©r√©
            print("üîç PartnerCodeService: checkExistingConnection - V√©rification code g√©n√©r√©")
            let codeSnapshot = try await db.collection("partnerCodes")
                .whereField("userId", isEqualTo: currentUser.uid)
                .getDocuments()
            
            if let codeDoc = codeSnapshot.documents.first {
                print("‚úÖ PartnerCodeService: checkExistingConnection - Code trouv√©: \(codeDoc.documentID)")
                await MainActor.run {
                    self.generatedCode = codeDoc.documentID
                }
            } else {
                print("üîç PartnerCodeService: checkExistingConnection - Aucun code g√©n√©r√©")
            }
            
        } catch {
            print("‚ùå PartnerCodeService: Erreur v√©rification connexion: \(error)")
        }
    }
    
    // MARK: - D√©connexion du partenaire (S√âCURIS√âE)
    
    func disconnectPartner() async -> Bool {
        print("üîó PartnerCodeService: disconnectPartner - D√©but d√©connexion s√©curis√©e")
        
        guard Auth.auth().currentUser != nil else { 
            print("‚ùå PartnerCodeService: disconnectPartner - Utilisateur non connect√©")
            return false 
        }
        
        await MainActor.run {
            self.isLoading = true
            self.errorMessage = nil
        }
        
        do {
            // Utiliser la fonction Cloud s√©curis√©e pour d√©connecter
            print("üîó PartnerCodeService: disconnectPartner - Appel Cloud Function")
            let functions = Functions.functions()
            let result = try await functions.httpsCallable("disconnectPartners").call([:])
            
            guard let data = result.data as? [String: Any],
                  let success = data["success"] as? Bool,
                  success else {
                print("‚ùå PartnerCodeService: disconnectPartner - √âchec Cloud Function")
                await MainActor.run {
                    self.errorMessage = "Erreur lors de la d√©connexion"
                    self.isLoading = false
                }
                return false
            }
            
            await MainActor.run {
                self.isConnected = false
                self.partnerInfo = nil
                self.isLoading = false
            }
            
            // üö® FIX: Vider lastCoupleId √† la d√©connexion pour √©viter faux positifs
            UserDefaults.standard.removeObject(forKey: "lastCoupleId")
            print("‚úÖ PartnerCodeService: lastCoupleId vid√© √† la d√©connexion")
            
            // Notifier la d√©connexion
            await MainActor.run {
                NotificationCenter.default.post(
                    name: .partnerDisconnected,
                    object: nil
                )
            }
            
            print("‚úÖ PartnerCodeService: D√©connexion r√©ussie via Cloud Function")
            return true
            
        } catch {
            await MainActor.run {
                self.errorMessage = "Erreur lors de la d√©connexion: \(error.localizedDescription)"
                self.isLoading = false
            }
            print("‚ùå PartnerCodeService: Erreur d√©connexion: \(error)")
            return false
        }
    }
    
    // MARK: - Suppression du code lors de la suppression du compte
    
    func deleteUserPartnerCode() async {
        guard let currentUser = Auth.auth().currentUser else { return }
        
        do {
            // Supprimer le code de l'utilisateur
            let codeSnapshot = try await db.collection("partnerCodes")
                .whereField("userId", isEqualTo: currentUser.uid)
                .getDocuments()
            
            for document in codeSnapshot.documents {
                try await document.reference.delete()
            }
            
            // Lib√©rer les codes o√π cet utilisateur √©tait connect√©
            let connectedCodesSnapshot = try await db.collection("partnerCodes")
                .whereField("connectedPartnerId", isEqualTo: currentUser.uid)
                .getDocuments()
            
            for document in connectedCodesSnapshot.documents {
                try await document.reference.updateData([
                    "connectedPartnerId": NSNull(),
                    "connectedAt": FieldValue.delete()
                ])
            }
            
            print("‚úÖ PartnerCodeService: Codes partenaire supprim√©s pour l'utilisateur")
            
        } catch {
            print("‚ùå PartnerCodeService: Erreur suppression codes: \(error)")
        }
    }
    
    // MARK: - Helpers
    
    func clearGeneratedCode() {
        generatedCode = nil
    }
    
    func clearError() {
        errorMessage = nil
    }
    
    // MARK: - V√©rifier les messages de connexion en attente
    
    func checkForPendingConnectionMessage() async {
        print("üîç PartnerCodeService: checkForPendingConnectionMessage - D√©but v√©rification")
        guard let currentUser = Auth.auth().currentUser else { 
            print("‚ùå PartnerCodeService: checkForPendingConnectionMessage - Utilisateur non connect√©")
            return 
        }
        
        do {
            print("üîç PartnerCodeService: checkForPendingConnectionMessage - Chargement donn√©es utilisateur")
            let doc = try await db.collection("users").document(currentUser.uid).getDocument()
            
            if let data = doc.data(),
               let hasUnreadConnection = data["hasUnreadPartnerConnection"] as? Bool,
               hasUnreadConnection,
               let partnerId = data["partnerId"] as? String,
               !partnerId.isEmpty {
                
                print("üîç PartnerCodeService: checkForPendingConnectionMessage - Message en attente pour partenaire: \(partnerId)")
                
                // üîß CORRECTION: Utiliser Cloud Function pour r√©cup√©rer le nom du partenaire
                do {
                    print("üîç PartnerCodeService: checkForPendingConnectionMessage - R√©cup√©ration nom via Cloud Function")
                    let functions = Functions.functions()
                    let result = try await functions.httpsCallable("getPartnerInfo").call([
                        "partnerId": partnerId
                    ])
                    
                    if let resultData = result.data as? [String: Any],
                       let success = resultData["success"] as? Bool,
                       success,
                       let partnerData = resultData["partnerInfo"] as? [String: Any],
                       let partnerName = partnerData["name"] as? String {
                        
                        print("‚úÖ PartnerCodeService: checkForPendingConnectionMessage - Nom partenaire: \(partnerName)")
                        
                        // Marquer comme lu
                        try await db.collection("users").document(currentUser.uid).updateData([
                            "hasUnreadPartnerConnection": FieldValue.delete()
                        ])
                        
                        await MainActor.run {
                            // Notifier qu'il faut afficher le message de connexion
                            NotificationCenter.default.post(
                                name: .shouldShowConnectionSuccess,
                                object: nil,
                                userInfo: ["partnerName": partnerName]
                            )
                        }
                        
                        print("‚úÖ PartnerCodeService: checkForPendingConnectionMessage - Notification envoy√©e")
                    } else {
                        print("‚ùå PartnerCodeService: checkForPendingConnectionMessage - √âchec r√©cup√©ration nom partenaire")
                    }
                } catch {
                    print("‚ùå PartnerCodeService: checkForPendingConnectionMessage - Erreur Cloud Function: \(error)")
                }
            } else {
                print("üîç PartnerCodeService: checkForPendingConnectionMessage - Aucun message en attente")
            }
            
        } catch {
            print("‚ùå PartnerCodeService: Erreur v√©rification message connexion: \(error)")
        }
    }
}

// MARK: - Notifications
extension Notification.Name {
    static let subscriptionInherited = Notification.Name("subscriptionInherited")
    static let partnerConnected = Notification.Name("partnerConnected")
    static let partnerDisconnected = Notification.Name("partnerDisconnected")
    static let partnerConnectionSuccess = Notification.Name("partnerConnectionSuccess")
    static let shouldShowConnectionSuccess = Notification.Name("shouldShowConnectionSuccess")
    static let subscriptionUpdated = Notification.Name("subscriptionUpdated")
    static let partnerSubscriptionShared = Notification.Name("partnerSubscriptionShared")
    static let partnerSubscriptionRevoked = Notification.Name("partnerSubscriptionRevoked")
    static let introFlagsDidReset = Notification.Name("introFlagsDidReset")
} 