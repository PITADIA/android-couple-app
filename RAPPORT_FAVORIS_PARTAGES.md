# Rapport : Syst√®me de Favoris Partag√©s - CoupleApp iOS

## Vue d'ensemble

Ce rapport d√©taille l'architecture compl√®te du syst√®me de favoris partag√©s dans l'application iOS CoupleApp, incluant la synchronisation temps r√©el entre partenaires, la s√©curit√© des donn√©es, l'int√©gration Firebase, et les recommandations pour l'adaptation Android.

---

## üèóÔ∏è Architecture G√©n√©rale du Syst√®me

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SYST√àME FAVORIS PARTAG√âS                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  COUCHE CLIENT iOS                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ  ‚îÇFavoritesService‚îÇ  ‚îÇFavoritesCardView‚îÇ  ‚îÇ QuestionListView ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ- addFavorite  ‚îÇ  ‚îÇ  - Swipe Cards‚îÇ  ‚îÇ- Favorite Button ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ- syncPartner  ‚îÇ  ‚îÇ  - Real-time ‚îÇ  ‚îÇ- Heart Toggle   ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ- realTimeSync ‚îÇ  ‚îÇ  - Author Info‚îÇ  ‚îÇ- Permissions    ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  COUCHE SYNCHRONISATION                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ  ‚îÇ Firestore    ‚îÇ  ‚îÇ   Listeners  ‚îÇ  ‚îÇ  Batch Updates‚îÇ          ‚îÇ
‚îÇ  ‚îÇ- arrayContains‚îÇ  ‚îÇ- Real-time  ‚îÇ  ‚îÇ- Atomic Ops   ‚îÇ         ‚îÇ
‚îÇ  ‚îÇ- partnerIds   ‚îÇ  ‚îÇ- Snapshots  ‚îÇ  ‚îÇ- Error Handling‚îÇ        ‚îÇ
‚îÇ  ‚îÇ- permissions  ‚îÇ  ‚îÇ- Automatic  ‚îÇ  ‚îÇ- Retry Logic  ‚îÇ         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  COUCHE FIREBASE BACKEND                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ  ‚îÇ Cloud Functions ‚îÇ  ‚îÇSecurity Rules ‚îÇ  ‚îÇ  Firestore   ‚îÇ         ‚îÇ
‚îÇ  ‚îÇ- syncPartnerFav‚îÇ  ‚îÇ- Partner Auth ‚îÇ  ‚îÇ- favoriteQuestions‚îÇ     ‚îÇ
‚îÇ  ‚îÇ- connectPartners‚îÇ  ‚îÇ- CRUD Control ‚îÇ  ‚îÇ- partnerIds[]  ‚îÇ      ‚îÇ
‚îÇ  ‚îÇ- batchUpdates  ‚îÇ  ‚îÇ- Read/Write   ‚îÇ  ‚îÇ- authorId      ‚îÇ      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

FLUX COMPLET:
1. Utilisateur ajoute question aux favoris ‚Üí FavoritesService.addFavorite()
2. SharedFavoriteQuestion cr√©√© avec partnerIds[] ‚Üí Firestore save
3. Listener temps r√©el d√©tecte changement ‚Üí handleFirestoreUpdate()
4. Interface mise √† jour automatiquement ‚Üí FavoritesCardView refresh
5. Partenaire voit instantan√©ment le nouveau favori
```

---

## üìä 1. Mod√®les de Donn√©es - Questions Favorites

### 1.1 FavoriteQuestion - Mod√®le Local

**Localisation :** `Models/FavoriteQuestion.swift:1-25`

```swift
struct FavoriteQuestion: Identifiable, Codable {
    let id: String
    let questionId: String
    let questionText: String
    let categoryTitle: String
    let emoji: String
    let dateAdded: Date

    init(
        id: String = UUID().uuidString,
        questionId: String,
        questionText: String,
        categoryTitle: String,
        emoji: String,
        dateAdded: Date = Date()
    ) {
        self.id = id
        self.questionId = questionId
        self.questionText = questionText
        self.categoryTitle = categoryTitle
        self.emoji = emoji
        self.dateAdded = dateAdded
    }

    // Convertir en Question standard
    func toQuestion() -> Question {
        return Question(id: questionId, text: questionText, category: categoryTitle)
    }
}
```

### 1.2 SharedFavoriteQuestion - Mod√®le Firestore Partag√©

**Localisation :** `Models/FavoriteQuestion.swift:29-109`

```swift
struct SharedFavoriteQuestion: Codable, Identifiable, Equatable {
    let id: String
    var questionId: String
    var questionText: String
    var categoryTitle: String
    var emoji: String
    var dateAdded: Date
    var createdAt: Date
    var updatedAt: Date

    // üîë CHAMPS DE PARTAGE
    var authorId: String           // Firebase UID de l'auteur
    var authorName: String         // Nom affich√© de l'auteur
    var isShared: Bool            // Si visible par le partenaire
    var partnerIds: [String]      // IDs des partenaires qui peuvent voir

    init(
        id: String = UUID().uuidString,
        questionId: String,
        questionText: String,
        categoryTitle: String,
        emoji: String,
        dateAdded: Date = Date(),
        authorId: String,
        authorName: String,
        isShared: Bool = true,
        partnerIds: [String] = []
    ) {
        self.id = id
        self.questionId = questionId
        self.questionText = questionText
        self.categoryTitle = categoryTitle
        self.emoji = emoji
        self.dateAdded = dateAdded
        self.createdAt = Date()
        self.updatedAt = Date()
        self.authorId = authorId
        self.authorName = authorName
        self.isShared = isShared
        self.partnerIds = partnerIds
    }

    // MARK: - Computed Properties

    var formattedDateAdded: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        formatter.locale = Locale.current
        return formatter.string(from: dateAdded)
    }

    // Convertir en FavoriteQuestion local
    func toLocalFavorite() -> FavoriteQuestion {
        return FavoriteQuestion(
            id: id,
            questionId: questionId,
            questionText: questionText,
            categoryTitle: categoryTitle,
            emoji: emoji,
            dateAdded: dateAdded
        )
    }
}
```

### 1.3 Extensions Firebase

```swift
extension SharedFavoriteQuestion {
    init?(from document: DocumentSnapshot) {
        guard let data = document.data() else { return nil }

        self.id = document.documentID
        self.questionId = data["questionId"] as? String ?? ""
        self.questionText = data["questionText"] as? String ?? ""
        self.categoryTitle = data["categoryTitle"] as? String ?? ""
        self.emoji = data["emoji"] as? String ?? ""

        // Conversion s√©curis√©e des timestamps
        if let timestamp = data["dateAdded"] as? Timestamp {
            self.dateAdded = timestamp.dateValue()
        } else {
            self.dateAdded = Date()
        }

        if let timestamp = data["createdAt"] as? Timestamp {
            self.createdAt = timestamp.dateValue()
        } else {
            self.createdAt = Date()
        }

        if let timestamp = data["updatedAt"] as? Timestamp {
            self.updatedAt = timestamp.dateValue()
        } else {
            self.updatedAt = Date()
        }

        // Champs de partage
        self.authorId = data["authorId"] as? String ?? ""
        self.authorName = data["authorName"] as? String ?? ""
        self.isShared = data["isShared"] as? Bool ?? true
        self.partnerIds = data["partnerIds"] as? [String] ?? []
    }

    func toDictionary() -> [String: Any] {
        return [
            "questionId": questionId,
            "questionText": questionText,
            "categoryTitle": categoryTitle,
            "emoji": emoji,
            "dateAdded": Timestamp(date: dateAdded),
            "createdAt": Timestamp(date: createdAt),
            "updatedAt": Timestamp(date: updatedAt),
            "authorId": authorId,
            "authorName": authorName,
            "isShared": isShared,
            "partnerIds": partnerIds
        ]
    }
}
```

---

## ‚öôÔ∏è 2. Service Principal - FavoritesService

### 2.1 Architecture FavoritesService

**Localisation :** `Services/FavoritesService.swift`

```swift
class FavoritesService: ObservableObject {
    // MARK: - Properties

    @Published var favoriteQuestions: [FavoriteQuestion] = []
    @Published var sharedFavoriteQuestions: [SharedFavoriteQuestion] = []
    @Published var isLoading: Bool = false

    private var listener: ListenerRegistration?
    private let db = Firestore.firestore()
    private var currentUserId: String?
    private var userName: String?
    private weak var appState: AppState?

    // MARK: - Initialization

    init(userId: String? = nil, userName: String? = nil) {
        self.currentUserId = userId
        self.userName = userName
        setupInitialData()
        setupFirestoreListener()
    }

    func setUserData(userId: String, userName: String, appState: AppState?) {
        self.currentUserId = userId
        self.userName = userName
        self.appState = appState

        // Red√©marrer le listener avec le nouveau user
        setupFirestoreListener()
    }
}
```

### 2.2 Synchronisation Temps R√©el - Firestore Listener

```swift
// MARK: - Firestore Listener

private func setupFirestoreListener() {
    guard let currentUserId = currentUserId else {
        print("‚ùå FavoritesService: Aucun utilisateur pour le listener")
        return
    }

    print("üî• FavoritesService: Configuration du listener Firestore")

    // Arr√™ter l'ancien listener
    listener?.remove()

    // Utiliser Firebase UID pour le listener
    let firebaseUID = Auth.auth().currentUser?.uid ?? currentUserId
    print("üî• FavoritesService: Listener configur√© avec Firebase UID")

    // üîë REQU√äTE TEMPS R√âEL
    listener = db.collection("favoriteQuestions")
        .whereField("partnerIds", arrayContains: firebaseUID)
        .addSnapshotListener { [weak self] snapshot, error in
            if let error = error {
                print("‚ùå FavoritesService: Erreur listener: \(error)")
                return
            }

            print("‚úÖ FavoritesService: R√©ception mise √† jour Firestore")
            if let documents = snapshot?.documents {
                print("‚úÖ FavoritesService: \(documents.count) document(s) re√ßu(s)")
            }

            self?.handleFirestoreUpdate(snapshot: snapshot)
        }
}

private func handleFirestoreUpdate(snapshot: QuerySnapshot?) {
    guard let documents = snapshot?.documents else {
        print("‚ùå FavoritesService: Pas de documents dans la mise √† jour")
        return
    }

    var updatedSharedFavorites: [SharedFavoriteQuestion] = []

    for document in documents {
        if let sharedFavorite = SharedFavoriteQuestion(from: document) {
            updatedSharedFavorites.append(sharedFavorite)
        }
    }

    print("üî• FavoritesService: \(updatedSharedFavorites.count) favoris partag√©s mis √† jour")

    DispatchQueue.main.async { [weak self] in
        self?.sharedFavoriteQuestions = updatedSharedFavorites
        print("‚úÖ FavoritesService: Interface mise √† jour")
    }
}
```

### 2.3 Ajout de Favori avec Partage Automatique

```swift
@MainActor
func addFavorite(question: Question, category: QuestionCategory) {
    guard let userId = currentUserId,
          let userName = userName else {
        print("‚ùå FavoritesService: Donn√©es utilisateur manquantes")
        return
    }

    isLoading = true

    Task {
        do {
            // üîë CONSTRUIRE LES PARTNER IDS
            var partnerIds: [String] = []

            // Toujours inclure l'auteur (Firebase UID)
            if let firebaseUID = Auth.auth().currentUser?.uid {
                partnerIds.append(firebaseUID)
            }

            // Ajouter le partenaire (Firebase UID)
            if let appState = appState, let partnerId = appState.currentUser?.partnerId {
                partnerIds.append(partnerId)
            }

            print("üî• FavoritesService: partnerIds construits: \(partnerIds)")

            // üîë CR√âER LE FAVORI PARTAG√â
            let sharedFavorite = SharedFavoriteQuestion(
                questionId: question.id,
                questionText: question.text,
                categoryTitle: category.title,
                emoji: category.emoji,
                authorId: Auth.auth().currentUser?.uid ?? userId,
                authorName: userName,
                partnerIds: partnerIds
            )

            // üîë SAUVEGARDER DANS FIRESTORE
            let documentRef = db.collection("favoriteQuestions").document(sharedFavorite.id)
            let data = sharedFavorite.toDictionary()

            try await documentRef.setData(data)

            print("‚úÖ FavoritesService: Favori partag√© sauvegard√©")
            print("‚úÖ FavoritesService: Document ID: \(sharedFavorite.id)")
            print("‚úÖ FavoritesService: Author ID: \(sharedFavorite.authorId)")
            print("‚úÖ FavoritesService: Partner IDs: \(sharedFavorite.partnerIds)")

            // Sauvegarder aussi localement (cache)
            addLocalFavorite(question: question, category: category, userId: userId)

            await MainActor.run {
                isLoading = false
            }

        } catch {
            print("‚ùå FavoritesService: Erreur sauvegarde Firestore: \(error)")
            await MainActor.run {
                isLoading = false
            }
        }
    }
}
```

### 2.4 Suppression avec Contr√¥le d'Autorisation

```swift
@MainActor
func removeFavorite(questionId: String) {
    guard let userId = currentUserId else {
        print("‚ùå FavoritesService: Pas d'utilisateur connect√©")
        return
    }

    print("üî• FavoritesService: SUPPRESSION - Question ID: \(questionId)")

    isLoading = true

    Task {
        do {
            // üîë V√âRIFICATION AUTORISATIONS
            if let sharedFavorite = sharedFavoriteQuestions.first(where: { $0.questionId == questionId }) {
                print("üî• FavoritesService: Favori trouv√© dans Firestore")

                let isAuthor = userId == sharedFavorite.authorId
                let isInPartnerIds = sharedFavorite.partnerIds.contains(userId)
                let canDelete = isAuthor || isInPartnerIds

                print("üî• FavoritesService: Est auteur: \(isAuthor)")
                print("üî• FavoritesService: Dans partnerIds: \(isInPartnerIds)")
                print("üî• FavoritesService: Peut supprimer: \(canDelete)")

                if canDelete {
                    // üîë SUPPRESSION FIRESTORE
                    try await db.collection("favoriteQuestions")
                        .document(sharedFavorite.id)
                        .delete()

                    print("‚úÖ FavoritesService: Favori partag√© supprim√© de Firestore")
                } else {
                    print("‚ùå FavoritesService: Pas d'autorisation de suppression")
                }
            }

            // Supprimer √©galement du cache local
            removeLocalFavorite(questionId: questionId, userId: userId)

            await MainActor.run {
                isLoading = false
            }

        } catch {
            print("‚ùå FavoritesService: Erreur suppression: \(error)")
            await MainActor.run {
                isLoading = false
            }
        }
    }
}

func canDeleteFavorite(questionId: String) -> Bool {
    guard let userId = currentUserId else {
        print("‚ùå FavoritesService: Pas d'utilisateur pour v√©rifier la suppression")
        return false
    }

    // üîë V√âRIFICATION PERMISSIONS
    if let sharedFavorite = sharedFavoriteQuestions.first(where: { $0.questionId == questionId }) {
        let isAuthor = userId == sharedFavorite.authorId
        let isInPartnerIds = sharedFavorite.partnerIds.contains(userId)
        let canDelete = isAuthor || isInPartnerIds

        print("üî• FavoritesService: Peut supprimer \(questionId): \(canDelete)")
        return canDelete
    }

    // Si c'est seulement un favori local, l'utilisateur peut le supprimer
    if favoriteQuestions.contains(where: { $0.questionId == questionId }) {
        return true
    }

    return false
}
```

### 2.5 Synchronisation des Partenaires

```swift
// MARK: - Partner Sync

func syncPartnerFavorites(partnerId: String, completion: @escaping (Bool, String?) -> Void) {
    print("‚ù§Ô∏è FavoritesService: D√©but synchronisation favoris avec partenaire")

    guard Auth.auth().currentUser != nil else {
        print("‚ùå FavoritesService: Aucun utilisateur connect√©")
        completion(false, "Utilisateur non connect√©")
        return
    }

    let functions = Functions.functions()
    let syncFunction = functions.httpsCallable("syncPartnerFavorites")

    syncFunction.call(["partnerId": partnerId]) { result, error in
        if let error = error {
            print("‚ùå FavoritesService: Erreur synchronisation favoris: \(error.localizedDescription)")
            completion(false, "Erreur lors de la synchronisation: \(error.localizedDescription)")
            return
        }

        guard let data = result?.data as? [String: Any],
              let success = data["success"] as? Bool else {
            print("‚ùå FavoritesService: R√©ponse invalide de la fonction")
            completion(false, "R√©ponse invalide du serveur")
            return
        }

        if success {
            let updatedCount = data["updatedFavoritesCount"] as? Int ?? 0
            print("‚úÖ FavoritesService: Synchronisation r√©ussie - \(updatedCount) favoris mis √† jour")
            completion(true, "Synchronisation r√©ussie: \(updatedCount) favoris mis √† jour")
        } else {
            let message = data["message"] as? String ?? "Erreur inconnue"
            print("‚ùå FavoritesService: √âchec synchronisation: \(message)")
            completion(false, message)
        }
    }
}

// MARK: - Data Access (Combin√©)

func getAllFavorites() -> [FavoriteQuestion] {
    // üîë COMBINER FAVORIS PARTAG√âS ET LOCAUX
    var allFavorites: [FavoriteQuestion] = []

    // Ajouter les favoris partag√©s convertis
    allFavorites.append(contentsOf: sharedFavoriteQuestions.map { $0.toLocalFavorite() })

    // Ajouter les favoris locaux qui ne sont pas d√©j√† dans les partag√©s
    for localFavorite in favoriteQuestions {
        if !allFavorites.contains(where: { $0.questionId == localFavorite.questionId }) {
            allFavorites.append(localFavorite)
        }
    }

    return allFavorites.sorted { $0.dateAdded > $1.dateAdded }
}
```

---

## üé® 3. Interface Utilisateur - FavoritesCardView

### 3.1 Architecture FavoritesCardView

**Localisation :** `Views/Main/FavoritesCardView.swift`

```swift
struct FavoritesCardView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var favoritesService: FavoritesService
    @EnvironmentObject private var appState: AppState

    @State private var currentIndex = 0
    @State private var dragOffset = CGSize.zero
    @State private var showingListView = false
    @State private var showingDeleteAlert = false

    // Favoris visibles (3 maximum pour la performance)
    private var visibleFavorites: [(Int, FavoriteQuestion)] {
        let allFavorites = favoritesService.getAllFavorites()
        guard !allFavorites.isEmpty else { return [] }

        let startIndex = max(0, currentIndex - 1)
        let endIndex = min(allFavorites.count - 1, currentIndex + 1)

        var result: [(Int, FavoriteQuestion)] = []
        for i in startIndex...endIndex {
            result.append((i, allFavorites[i]))
        }
        return result
    }

    var body: some View {
        ZStack {
            // Fond d√©grad√©
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red: 0.97, green: 0.97, blue: 0.98),
                    Color(red: 0.95, green: 0.95, blue: 0.97)
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea(.all)

            VStack(spacing: 0) {
                // Header
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.system(size: 18, weight: .medium))
                            .foregroundColor(.black)
                    }

                    Spacer()

                    Text("Favoris Partag√©s")
                        .font(.system(size: 24, weight: .bold))
                        .foregroundColor(.black)

                    Spacer()

                    Button(action: { showingListView = true }) {
                        Image(systemName: "list.bullet")
                            .font(.system(size: 18, weight: .medium))
                            .foregroundColor(.black)
                    }
                }
                .padding(.horizontal, 20)
                .padding(.top, 20)

                Spacer(minLength: 40)

                // Contenu principal
                if favoritesService.getAllFavorites().isEmpty {
                    EmptyFavoritesView()
                        .padding(.horizontal, 20)
                } else {
                    // üîë CARTES SWIPABLES
                    GeometryReader { geometry in
                        let cardWidth = geometry.size.width - 40
                        let cardSpacing: CGFloat = 30

                        ZStack {
                            ForEach(visibleFavorites, id: \.0) { indexAndFavorite in
                                let (index, favorite) = indexAndFavorite
                                let offset = CGFloat(index - currentIndex)
                                let xPosition = offset * (cardWidth + cardSpacing) + dragOffset.width

                                FavoriteQuestionCardView(
                                    favorite: favorite,
                                    isBackground: index != currentIndex
                                )
                                .frame(width: cardWidth)
                                .offset(x: xPosition)
                                .scaleEffect(index == currentIndex ? 1.0 : 0.95)
                                .opacity(index == currentIndex ? 1.0 : 0.8)
                            }
                        }
                        .gesture(
                            DragGesture()
                                .onChanged { value in
                                    dragOffset = value.translation
                                }
                                .onEnded { value in
                                    withAnimation(.easeOut(duration: 0.3)) {
                                        handleSwipeGesture(translation: value.translation)
                                        dragOffset = .zero
                                    }
                                }
                        )
                    }
                    .frame(height: 400)
                }

                Spacer()

                // Indicateurs de page
                if !favoritesService.getAllFavorites().isEmpty {
                    PageIndicator(
                        currentIndex: currentIndex,
                        totalCount: favoritesService.getAllFavorites().count
                    )
                    .padding(.bottom, 40)
                }
            }
        }
        .sheet(isPresented: $showingListView) {
            FavoritesListView()
                .environmentObject(favoritesService)
        }
        .alert("Supprimer ce favori ?", isPresented: $showingDeleteAlert) {
            Button("Annuler", role: .cancel) { }
            Button("Supprimer", role: .destructive) {
                removeFavoriteAtCurrentIndex()
            }
        }
    }

    private func handleSwipeGesture(translation: CGSize) {
        let threshold: CGFloat = 50
        let allFavorites = favoritesService.getAllFavorites()

        if translation.x > threshold && currentIndex > 0 {
            // Swipe vers la droite - favori pr√©c√©dent
            currentIndex -= 1
        } else if translation.x < -threshold && currentIndex < allFavorites.count - 1 {
            // Swipe vers la gauche - favori suivant
            currentIndex += 1
        }
    }
}
```

### 3.2 Carte Favorite Individuelle

```swift
struct FavoriteQuestionCardView: View {
    let favorite: FavoriteQuestion
    let isBackground: Bool

    var body: some View {
        VStack(spacing: 0) {
            // üîë HEADER DE LA CARTE AVEC INFORMATIONS CAT√âGORIE
            VStack(spacing: 8) {
                Text(favorite.categoryTitle)
                    .font(.system(size: 18, weight: .bold))
                    .foregroundColor(.white)
                    .multilineTextAlignment(.center)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 20)
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color(red: 1.0, green: 0.4, blue: 0.6),
                        Color(red: 1.0, green: 0.6, blue: 0.8)
                    ]),
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )

            // üîë CORPS DE LA CARTE AVEC LA QUESTION
            VStack(spacing: 30) {
                Spacer()

                Text(favorite.questionText)
                    .font(.system(size: 22, weight: .medium))
                    .foregroundColor(.white)
                    .multilineTextAlignment(.center)
                    .lineSpacing(6)
                    .padding(.horizontal, 30)

                Spacer()

                // üîë INFORMATIONS D'AUTEUR (pour favoris partag√©s)
                if let sharedFavorite = getSharedFavorite(for: favorite) {
                    HStack(spacing: 8) {
                        Image(systemName: "heart.fill")
                            .font(.system(size: 16))
                            .foregroundColor(.white.opacity(0.8))

                        Text("Ajout√© par \(sharedFavorite.authorName)")
                            .font(.system(size: 14, weight: .medium))
                            .foregroundColor(.white.opacity(0.8))

                        Text("‚Ä¢")
                            .foregroundColor(.white.opacity(0.6))

                        Text(sharedFavorite.formattedDateAdded)
                            .font(.system(size: 12))
                            .foregroundColor(.white.opacity(0.6))
                    }
                    .padding(.bottom, 10)
                }

                // Logo/Branding
                HStack(spacing: 8) {
                    Image("leetchi2")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 24, height: 24)

                    Text("Love2Love")
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(.white.opacity(0.9))
                }
                .padding(.bottom, 30)
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color(red: 0.8, green: 0.2, blue: 0.4),
                        Color(red: 0.9, green: 0.3, blue: 0.5)
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
        }
        .frame(height: 400)
        .cornerRadius(20)
        .shadow(color: .black.opacity(0.15), radius: 8, x: 0, y: 4)
        .scaleEffect(isBackground ? 0.95 : 1.0)
        .opacity(isBackground ? 0.8 : 1.0)
    }

    private func getSharedFavorite(for favorite: FavoriteQuestion) -> SharedFavoriteQuestion? {
        // R√©cup√©rer les informations partag√©es depuis FavoritesService
        // Ceci n√©cessite un acc√®s au service via EnvironmentObject
        return nil // Impl√©mentation simplifi√©e
    }
}
```

---

## üî• 4. Firebase Backend - Cloud Functions

### 4.1 syncPartnerFavorites() - Synchronisation Bidirectionnelle

**Localisation :** `firebase/functions/index.js:3389-3465`

```javascript
exports.syncPartnerFavorites = functions.https.onCall(async (data, context) => {
  console.log("‚ù§Ô∏è syncPartnerFavorites: D√©but synchronisation favoris");

  // üîë V√âRIFICATION AUTHENTIFICATION
  if (!context.auth) {
    throw new functions.https.HttpsError(
      "unauthenticated",
      "Utilisateur non authentifi√©"
    );
  }

  const currentUserId = context.auth.uid;
  const { partnerId } = data;

  // üîë VALIDATION S√âCURIS√âE DES PARAM√àTRES
  if (!partnerId || typeof partnerId !== "string" || partnerId.trim() === "") {
    throw new functions.https.HttpsError(
      "invalid-argument",
      "ID partenaire requis"
    );
  }

  try {
    // üîë V√âRIFICATION CONNEXION PARTENAIRE
    const [currentUserDoc, partnerUserDoc] = await Promise.all([
      admin.firestore().collection("users").doc(currentUserId).get(),
      admin.firestore().collection("users").doc(partnerId).get(),
    ]);

    if (!currentUserDoc.exists || !partnerUserDoc.exists) {
      throw new functions.https.HttpsError(
        "not-found",
        "Utilisateur ou partenaire non trouv√©"
      );
    }

    const currentUserData = currentUserDoc.data();
    const partnerUserData = partnerUserDoc.data();

    // üîë V√âRIFICATION BIDIRECTIONNELLE DE LA CONNEXION
    if (
      currentUserData.partnerId !== partnerId ||
      partnerUserData.partnerId !== currentUserId
    ) {
      throw new functions.https.HttpsError(
        "permission-denied",
        "Les utilisateurs ne sont pas connect√©s en tant que partenaires"
      );
    }

    console.log("‚ù§Ô∏è syncPartnerFavorites: Connexion partenaire v√©rifi√©e");

    // üîë APPELER LA FONCTION INTERNE DE SYNCHRONISATION
    const result = await syncPartnerFavoritesInternal(currentUserId, partnerId);

    return {
      success: true,
      updatedFavoritesCount: result.updatedFavoritesCount,
      userFavoritesCount: result.userFavoritesCount,
      partnerFavoritesCount: result.partnerFavoritesCount,
      message: `Synchronisation termin√©e: ${result.updatedFavoritesCount} favoris mis √† jour`,
    };
  } catch (error) {
    console.error("‚ùå syncPartnerFavorites: Erreur:", error);

    // Si c'est d√©j√† une HttpsError, la relancer
    if (error.code && error.message) {
      throw error;
    }

    throw new functions.https.HttpsError("internal", error.message);
  }
});
```

### 4.2 syncPartnerFavoritesInternal() - Logique Interne

**Localisation :** `firebase/functions/index.js:3312-3386`

```javascript
async function syncPartnerFavoritesInternal(currentUserId, partnerId) {
  console.log("‚ù§Ô∏è syncPartnerFavoritesInternal: D√©but synchronisation");

  // üîë R√âCUP√âRER TOUS LES FAVORIS DE L'UTILISATEUR ACTUEL
  const currentUserFavoritesSnapshot = await admin
    .firestore()
    .collection("favoriteQuestions")
    .where("authorId", "==", currentUserId)
    .get();

  // üîë R√âCUP√âRER TOUS LES FAVORIS DU PARTENAIRE
  const partnerFavoritesSnapshot = await admin
    .firestore()
    .collection("favoriteQuestions")
    .where("authorId", "==", partnerId)
    .get();

  let updatedCount = 0;
  const batch = admin.firestore().batch();

  // üîë MISE √Ä JOUR DES FAVORIS DE L'UTILISATEUR ACTUEL
  for (const doc of currentUserFavoritesSnapshot.docs) {
    const favoriteData = doc.data();
    const currentPartnerIds = favoriteData.partnerIds || [];

    // Ajouter le partenaire s'il n'est pas d√©j√† pr√©sent
    if (!currentPartnerIds.includes(partnerId)) {
      const updatedPartnerIds = [...currentPartnerIds, partnerId];
      batch.update(doc.ref, {
        partnerIds: updatedPartnerIds,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });
      updatedCount++;
      console.log(`‚ù§Ô∏è Mise √† jour favori utilisateur: ${doc.id}`);
    }
  }

  // üîë MISE √Ä JOUR DES FAVORIS DU PARTENAIRE
  for (const doc of partnerFavoritesSnapshot.docs) {
    const favoriteData = doc.data();
    const currentPartnerIds = favoriteData.partnerIds || [];

    // Ajouter l'utilisateur actuel s'il n'est pas d√©j√† pr√©sent
    if (!currentPartnerIds.includes(currentUserId)) {
      const updatedPartnerIds = [...currentPartnerIds, currentUserId];
      batch.update(doc.ref, {
        partnerIds: updatedPartnerIds,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });
      updatedCount++;
      console.log(`‚ù§Ô∏è Mise √† jour favori partenaire: ${doc.id}`);
    }
  }

  // üîë EX√âCUTION BATCH ATOMIQUE
  if (updatedCount > 0) {
    await batch.commit();
    console.log(
      `‚úÖ syncPartnerFavoritesInternal: ${updatedCount} favoris mis √† jour`
    );
  } else {
    console.log(
      "‚ÑπÔ∏è syncPartnerFavoritesInternal: Aucune mise √† jour n√©cessaire"
    );
  }

  return {
    updatedFavoritesCount: updatedCount,
    userFavoritesCount: currentUserFavoritesSnapshot.docs.length,
    partnerFavoritesCount: partnerFavoritesSnapshot.docs.length,
  };
}
```

### 4.3 Synchronisation Automatique lors de la Connexion Partenaire

**Localisation :** `firebase/functions/index.js:2122-2141`

```javascript
// Dans la fonction connectPartners()

// 7. Synchroniser automatiquement les favoris existants
try {
  console.log("‚ù§Ô∏è connectPartners: Synchronisation des favoris...");

  // üîë APPELER LA SYNCHRONISATION INTERNE DES FAVORIS
  const syncFavoritesResult = await syncPartnerFavoritesInternal(
    currentUserId,
    partnerUserId
  );

  console.log(
    `‚úÖ connectPartners: Synchronisation favoris termin√©e - ${syncFavoritesResult.updatedFavoritesCount} favoris mis √† jour`
  );
} catch (syncError) {
  console.error(
    "‚ùå connectPartners: Erreur synchronisation favoris:",
    syncError
  );
  // Ne pas faire √©chouer la connexion pour une erreur de synchronisation
}
```

---

## üîí 5. S√©curit√© et Permissions

### 5.1 R√®gles de S√©curit√© Firestore

**Localisation :** `firebase/firestore.rules` (structure recommand√©e)

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // R√®gles pour la collection favoriteQuestions
    match /favoriteQuestions/{favoriteId} {

      // üîë LECTURE : Autoris√©e si l'utilisateur est dans partnerIds
      allow read: if request.auth != null &&
                     request.auth.uid in resource.data.partnerIds;

      // üîë CR√âATION : Autoris√©e si l'utilisateur authentifi√© est l'auteur
      allow create: if request.auth != null &&
                       request.auth.uid == resource.data.authorId &&
                       request.auth.uid in resource.data.partnerIds;

      // üîë MISE √Ä JOUR : Autoris√©e si l'utilisateur est l'auteur ou dans partnerIds
      allow update: if request.auth != null &&
                       (request.auth.uid == resource.data.authorId ||
                        request.auth.uid in resource.data.partnerIds);

      // üîë SUPPRESSION : Autoris√©e si l'utilisateur est l'auteur ou dans partnerIds
      allow delete: if request.auth != null &&
                       (request.auth.uid == resource.data.authorId ||
                        request.auth.uid in resource.data.partnerIds);
    }

    // Autres r√®gles pour users, etc...
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
```

### 5.2 Contr√¥les d'Acc√®s c√¥t√© Client iOS

```swift
// Dans FavoritesService.swift

func canDeleteFavorite(questionId: String) -> Bool {
    guard let userId = currentUserId else { return false }

    // üîë V√âRIFICATION PERMISSIONS LOCALES
    if let sharedFavorite = sharedFavoriteQuestions.first(where: { $0.questionId == questionId }) {

        let isAuthor = userId == sharedFavorite.authorId
        let isInPartnerIds = sharedFavorite.partnerIds.contains(userId)
        let canDelete = isAuthor || isInPartnerIds

        print("üîí Permissions: Est auteur: \(isAuthor)")
        print("üîí Permissions: Dans partnerIds: \(isInPartnerIds)")
        print("üîí Permissions: Peut supprimer: \(canDelete)")

        return canDelete
    }

    // Si c'est seulement un favori local, l'utilisateur peut le supprimer
    return favoriteQuestions.contains(where: { $0.questionId == questionId })
}

private func validateFavoriteAccess(favorite: SharedFavoriteQuestion, userId: String) -> Bool {
    // üîë VALIDATION D'ACC√àS MULTI-NIVEAUX

    // 1. V√©rifier si l'utilisateur est l'auteur
    if favorite.authorId == userId {
        print("üîí Acc√®s autoris√©: Utilisateur est l'auteur")
        return true
    }

    // 2. V√©rifier si l'utilisateur est dans la liste des partenaires
    if favorite.partnerIds.contains(userId) {
        print("üîí Acc√®s autoris√©: Utilisateur dans partnerIds")
        return true
    }

    // 3. V√©rifier si le favori est marqu√© comme partag√©
    if !favorite.isShared {
        print("üîí Acc√®s refus√©: Favori non partag√©")
        return false
    }

    print("üîí Acc√®s refus√©: Utilisateur non autoris√©")
    return false
}
```

### 5.3 Logging S√©curis√© et Audit

```swift
// Dans FavoritesService.swift

private func logSecureAction(action: String, questionId: String, details: [String: Any] = [:]) {
    let logData: [String: Any] = [
        "action": action,
        "questionId": questionId,
        "timestamp": Date().timeIntervalSince1970,
        "userId": currentUserId?.prefix(8) ?? "unknown", // Hash partiel pour s√©curit√©
        "details": details
    ]

    // Logger vers Firebase Analytics pour audit
    Analytics.logEvent("favorites_security_action", parameters: [
        "action": action,
        "has_partner": appState?.currentUser?.partnerId != nil,
        "favorites_count": getAllFavorites().count
    ])

    print("üîí AUDIT: \(action) - Question: \(questionId)")
}

// Utilisation dans les m√©thodes critiques
@MainActor
func addFavorite(question: Question, category: QuestionCategory) {
    logSecureAction(
        action: "add_favorite",
        questionId: question.id,
        details: ["category": category.title]
    )

    // ... reste de l'impl√©mentation
}

@MainActor
func removeFavorite(questionId: String) {
    logSecureAction(
        action: "remove_favorite",
        questionId: questionId
    )

    // ... reste de l'impl√©mentation
}
```

---

## üì± 6. Structure Firebase Firestore

### 6.1 Collection "favoriteQuestions"

```javascript
// Document dans favoriteQuestions/{favoriteId}
{
  "id": "uuid-generated-id",
  "questionId": "question_123",
  "questionText": "Quelle est ta plus grande fiert√© dans notre relation ?",
  "categoryTitle": "En Couple",
  "emoji": "üíï",

  // üîë M√âTADONN√âES TEMPORELLES
  "dateAdded": Timestamp,        // Quand l'utilisateur a ajout√© aux favoris
  "createdAt": Timestamp,        // Quand le document a √©t√© cr√©√©
  "updatedAt": Timestamp,        // Derni√®re mise √† jour

  // üîë INFORMATIONS D'AUTEUR
  "authorId": "firebase-uid-123",     // Firebase UID de celui qui a ajout√©
  "authorName": "Marie",              // Nom affich√© de l'auteur

  // üîë CONTR√îLE DE PARTAGE
  "isShared": true,                   // Si visible par le partenaire
  "partnerIds": [                     // Utilisateurs qui peuvent voir ce favori
    "firebase-uid-123",               // Auteur (toujours inclus)
    "firebase-uid-456"                // Partenaire connect√©
  ]
}
```

### 6.2 Index Firestore Recommand√©s

```javascript
// Index pour optimiser les requ√™tes

// Index composite pour la requ√™te principale
{
  "collectionGroup": "favoriteQuestions",
  "queryScope": "COLLECTION",
  "fields": [
    {
      "fieldPath": "partnerIds",
      "arrayConfig": "CONTAINS"
    },
    {
      "fieldPath": "updatedAt",
      "order": "DESCENDING"
    }
  ]
}

// Index pour les requ√™tes par auteur
{
  "collectionGroup": "favoriteQuestions",
  "queryScope": "COLLECTION",
  "fields": [
    {
      "fieldPath": "authorId",
      "order": "ASCENDING"
    },
    {
      "fieldPath": "createdAt",
      "order": "DESCENDING"
    }
  ]
}

// Index pour les recherches par cat√©gorie
{
  "collectionGroup": "favoriteQuestions",
  "queryScope": "COLLECTION",
  "fields": [
    {
      "fieldPath": "partnerIds",
      "arrayConfig": "CONTAINS"
    },
    {
      "fieldPath": "categoryTitle",
      "order": "ASCENDING"
    },
    {
      "fieldPath": "dateAdded",
      "order": "DESCENDING"
    }
  ]
}
```

---

## üîÑ 7. Flux Complets - Sc√©narios d'Usage

### 7.1 Sc√©nario 1: Ajout de Favori avec Partage Instantan√©

```
√âTAPE 1: Utilisateur Marie ajoute une question aux favoris
‚îú‚îÄ QuestionListView ‚Üí Tap sur ic√¥ne c≈ìur
‚îú‚îÄ FavoritesService.addFavorite(question, category)
‚îú‚îÄ Construction partnerIds: ["marie_uid", "paul_uid"]
‚îî‚îÄ SharedFavoriteQuestion cr√©√© avec authorId = "marie_uid"

√âTAPE 2: Sauvegarde Firebase
‚îú‚îÄ Firestore.collection("favoriteQuestions").setData()
‚îú‚îÄ Document sauvegard√© avec partnerIds = ["marie_uid", "paul_uid"]
‚îî‚îÄ Listener temps r√©el d√©clench√©

√âTAPE 3: Synchronisation automatique c√¥t√© Paul
‚îú‚îÄ Paul's FavoritesService listener d√©tecte le changement
‚îú‚îÄ handleFirestoreUpdate() appel√©
‚îú‚îÄ sharedFavoriteQuestions mis √† jour
‚îî‚îÄ Interface FavoritesCardView se rafra√Æchit automatiquement

√âTAPE 4: Affichage instantan√© chez Paul
‚îú‚îÄ Paul voit le nouveau favori dans FavoritesCardView
‚îú‚îÄ M√©tadonn√©es affich√©es: "Ajout√© par Marie ‚Ä¢ il y a 2 minutes"
‚îî‚îÄ Paul peut maintenant swiper, visualiser, supprimer

R√âSULTAT:
‚úÖ Marie: Favori ajout√© et visible imm√©diatement
‚úÖ Paul: Favori partag√© re√ßu en temps r√©el
‚úÖ Synchronisation bidirectionnelle active
```

### 7.2 Sc√©nario 2: Connexion de Nouveaux Partenaires

```
√âTAPE 1: √âtat initial
‚îú‚îÄ Marie: 15 favoris existants (partnerIds = ["marie_uid"])
‚îú‚îÄ Paul: 8 favoris existants (partnerIds = ["paul_uid"])
‚îî‚îÄ Aucune connexion entre eux

√âTAPE 2: Connexion via code partenaire
‚îú‚îÄ Paul saisit le code de Marie
‚îú‚îÄ connectPartners() Cloud Function appel√©e
‚îú‚îÄ V√©rifications de s√©curit√© pass√©es
‚îî‚îÄ Connexion bidirectionnelle √©tablie

√âTAPE 3: Synchronisation automatique des favoris
‚îú‚îÄ syncPartnerFavoritesInternal(marie_uid, paul_uid) appel√©e
‚îú‚îÄ Favoris de Marie: partnerIds mis √† jour ‚Üí ["marie_uid", "paul_uid"]
‚îú‚îÄ Favoris de Paul: partnerIds mis √† jour ‚Üí ["paul_uid", "marie_uid"]
‚îî‚îÄ 23 favoris mis √† jour (15 + 8) via batch update

√âTAPE 4: R√©ception temps r√©el
‚îú‚îÄ Marie: Listener d√©tecte 8 nouveaux favoris de Paul
‚îú‚îÄ Paul: Listener d√©tecte 15 nouveaux favoris de Marie
‚îú‚îÄ Interfaces mises √† jour automatiquement
‚îî‚îÄ Notification: "Synchronisation r√©ussie: 23 favoris mis √† jour"

R√âSULTAT:
‚úÖ Marie: Voit ses 15 favoris + 8 favoris de Paul (23 total)
‚úÖ Paul: Voit ses 8 favoris + 15 favoris de Marie (23 total)
‚úÖ Partage bidirectionnel complet activ√©
‚úÖ Futurs favoris automatiquement partag√©s
```

### 7.3 Sc√©nario 3: Suppression avec Contr√¥le d'Autorisation

```
√âTAPE 1: Paul veut supprimer un favori de Marie
‚îú‚îÄ FavoritesCardView ‚Üí Long press sur carte
‚îú‚îÄ Alert "Supprimer ce favori ?" affich√©
‚îî‚îÄ Paul confirme la suppression

√âTAPE 2: V√©rification des permissions
‚îú‚îÄ FavoritesService.canDeleteFavorite(questionId)
‚îú‚îÄ Favori trouv√©: authorId = "marie_uid", partnerIds = ["marie_uid", "paul_uid"]
‚îú‚îÄ Paul n'est pas l'auteur MAIS est dans partnerIds
‚îî‚îÄ Suppression autoris√©e ‚úÖ

√âTAPE 3: Suppression Firestore
‚îú‚îÄ FavoritesService.removeFavorite(questionId)
‚îú‚îÄ Document supprim√© de Firestore via .delete()
‚îî‚îÄ Listener temps r√©el d√©clench√©

√âTAPE 4: Mise √† jour bidirectionnelle
‚îú‚îÄ Paul: Favori supprim√© de son interface imm√©diatement
‚îú‚îÄ Marie: Listener d√©tecte la suppression
‚îú‚îÄ Favori supprim√© de l'interface de Marie
‚îî‚îÄ Synchronisation compl√®te

R√âSULTAT:
‚úÖ Paul: Favori supprim√© avec succ√®s
‚úÖ Marie: Favori supprim√© de ses favoris automatiquement
‚úÖ Coh√©rence des donn√©es maintenue
‚úÖ Audit de suppression log√© pour conformit√©
```

---

## ü§ñ 8. Adaptation Android - Architecture Kotlin

### 8.1 FavoritesRepository Android

```kotlin
@Singleton
class FavoritesRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val functions: FirebaseFunctions,
    private val analyticsService: AnalyticsService,
    private val authRepository: AuthRepository
) {

    companion object {
        private const val TAG = "FavoritesRepository"
        private const val COLLECTION_FAVORITES = "favoriteQuestions"
    }

    private val _favoriteQuestions = MutableStateFlow<List<FavoriteQuestion>>(emptyList())
    val favoriteQuestions: StateFlow<List<FavoriteQuestion>> = _favoriteQuestions

    private val _sharedFavorites = MutableStateFlow<List<SharedFavoriteQuestion>>(emptyList())
    val sharedFavorites: StateFlow<List<SharedFavoriteQuestion>> = _sharedFavorites

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    private var favoritesListener: ListenerRegistration? = null

    // MARK: - Initialization

    fun initializeForUser(userId: String, userName: String) {
        Log.d(TAG, "Initialisation pour utilisateur: $userId")
        setupRealtimeListener(userId)
    }

    // MARK: - Real-time Listener

    private fun setupRealtimeListener(userId: String) {
        favoritesListener?.remove()

        Log.d(TAG, "Configuration listener temps r√©el pour: $userId")

        // üîë LISTENER FIREBASE TEMPS R√âEL
        favoritesListener = firestore.collection(COLLECTION_FAVORITES)
            .whereArrayContains("partnerIds", userId)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    Log.e(TAG, "Erreur listener favoris: ${error.message}")
                    return@addSnapshotListener
                }

                Log.d(TAG, "Mise √† jour favoris re√ßue: ${snapshot?.documents?.size} documents")

                val updatedFavorites = snapshot?.documents?.mapNotNull { doc ->
                    try {
                        SharedFavoriteQuestion.fromFirestore(doc)
                    } catch (e: Exception) {
                        Log.e(TAG, "Erreur parsing favori: ${e.message}")
                        null
                    }
                } ?: emptyList()

                _sharedFavorites.value = updatedFavorites
                Log.d(TAG, "Favoris partag√©s mis √† jour: ${updatedFavorites.size}")
            }
    }

    // MARK: - Add Favorite

    suspend fun addFavorite(
        question: Question,
        category: QuestionCategory,
        partnerId: String?
    ): Result<Unit> {
        return try {
            _isLoading.value = true

            val currentUser = authRepository.getCurrentUser()
                ?: return Result.failure(Exception("Utilisateur non connect√©"))

            // üîë CONSTRUCTION PARTNER IDS
            val partnerIds = mutableListOf<String>().apply {
                add(currentUser.uid) // Toujours inclure l'auteur
                partnerId?.let { add(it) } // Ajouter le partenaire si pr√©sent
            }

            Log.d(TAG, "Ajout favori avec partnerIds: $partnerIds")

            // üîë CR√âATION SHARED FAVORITE
            val sharedFavorite = SharedFavoriteQuestion(
                questionId = question.id,
                questionText = question.text,
                categoryTitle = category.title,
                emoji = category.emoji,
                authorId = currentUser.uid,
                authorName = currentUser.displayName ?: "Utilisateur",
                partnerIds = partnerIds
            )

            // üîë SAUVEGARDE FIRESTORE
            firestore.collection(COLLECTION_FAVORITES)
                .document(sharedFavorite.id)
                .set(sharedFavorite.toFirestore())
                .await()

            Log.d(TAG, "Favori sauvegard√© avec succ√®s: ${sharedFavorite.id}")

            // Analytics
            analyticsService.logEvent("favorite_added") {
                param("category", category.title)
                param("has_partner", partnerId != null)
            }

            _isLoading.value = false
            Result.success(Unit)

        } catch (e: Exception) {
            Log.e(TAG, "Erreur ajout favori: ${e.message}")
            _isLoading.value = false
            Result.failure(e)
        }
    }

    // MARK: - Remove Favorite

    suspend fun removeFavorite(questionId: String, userId: String): Result<Unit> {
        return try {
            _isLoading.value = true

            // üîë TROUVER LE FAVORI ET V√âRIFIER LES PERMISSIONS
            val sharedFavorite = _sharedFavorites.value.find { it.questionId == questionId }
                ?: return Result.failure(Exception("Favori non trouv√©"))

            val canDelete = canDeleteFavorite(sharedFavorite, userId)
            if (!canDelete) {
                Log.w(TAG, "Tentative de suppression non autoris√©e")
                return Result.failure(Exception("Suppression non autoris√©e"))
            }

            // üîë SUPPRESSION FIRESTORE
            firestore.collection(COLLECTION_FAVORITES)
                .document(sharedFavorite.id)
                .delete()
                .await()

            Log.d(TAG, "Favori supprim√© avec succ√®s: ${sharedFavorite.id}")

            // Analytics
            analyticsService.logEvent("favorite_removed") {
                param("category", sharedFavorite.categoryTitle)
                param("is_author", userId == sharedFavorite.authorId)
            }

            _isLoading.value = false
            Result.success(Unit)

        } catch (e: Exception) {
            Log.e(TAG, "Erreur suppression favori: ${e.message}")
            _isLoading.value = false
            Result.failure(e)
        }
    }

    // MARK: - Permissions

    fun canDeleteFavorite(favorite: SharedFavoriteQuestion, userId: String): Boolean {
        val isAuthor = favorite.authorId == userId
        val isInPartnerIds = favorite.partnerIds.contains(userId)
        val canDelete = isAuthor || isInPartnerIds

        Log.d(TAG, "Permissions suppression - Est auteur: $isAuthor, Dans partnerIds: $isInPartnerIds")
        return canDelete
    }

    // MARK: - Partner Sync

    suspend fun syncPartnerFavorites(partnerId: String): Result<SyncResult> {
        return try {
            Log.d(TAG, "D√©but synchronisation favoris avec partenaire")

            val data = hashMapOf("partnerId" to partnerId)

            val result = functions.getHttpsCallable("syncPartnerFavorites")
                .call(data)
                .await()

            val resultData = result.data as? Map<String, Any>
                ?: return Result.failure(Exception("R√©ponse invalide"))

            val success = resultData["success"] as? Boolean ?: false
            if (!success) {
                val message = resultData["message"] as? String ?: "Erreur inconnue"
                return Result.failure(Exception(message))
            }

            val syncResult = SyncResult(
                updatedFavoritesCount = (resultData["updatedFavoritesCount"] as? Number)?.toInt() ?: 0,
                userFavoritesCount = (resultData["userFavoritesCount"] as? Number)?.toInt() ?: 0,
                partnerFavoritesCount = (resultData["partnerFavoritesCount"] as? Number)?.toInt() ?: 0
            )

            Log.d(TAG, "Synchronisation r√©ussie: ${syncResult.updatedFavoritesCount} favoris mis √† jour")

            analyticsService.logEvent("favorites_synced") {
                param("updated_count", syncResult.updatedFavoritesCount.toLong())
            }

            Result.success(syncResult)

        } catch (e: Exception) {
            Log.e(TAG, "Erreur synchronisation: ${e.message}")
            Result.failure(e)
        }
    }

    // MARK: - Data Access

    fun getAllFavorites(): StateFlow<List<FavoriteQuestion>> {
        return _sharedFavorites.map { sharedFavorites ->
            // üîë COMBINER ET TRIER LES FAVORIS
            sharedFavorites
                .map { it.toLocalFavorite() }
                .sortedByDescending { it.dateAdded }
        }.stateIn(
            scope = CoroutineScope(Dispatchers.IO),
            started = SharingStarted.WhileSubscribed(),
            initialValue = emptyList()
        )
    }

    fun cleanup() {
        favoritesListener?.remove()
        favoritesListener = null
    }
}

// MARK: - Data Classes

data class SyncResult(
    val updatedFavoritesCount: Int,
    val userFavoritesCount: Int,
    val partnerFavoritesCount: Int
)
```

### 8.2 Mod√®les de Donn√©es Android

```kotlin
// FavoriteQuestion.kt
data class FavoriteQuestion(
    val id: String,
    val questionId: String,
    val questionText: String,
    val categoryTitle: String,
    val emoji: String,
    val dateAdded: Date
) {
    fun toQuestion(): Question {
        return Question(
            id = questionId,
            text = questionText,
            category = categoryTitle
        )
    }
}

// SharedFavoriteQuestion.kt
data class SharedFavoriteQuestion(
    val id: String = UUID.randomUUID().toString(),
    val questionId: String,
    val questionText: String,
    val categoryTitle: String,
    val emoji: String,
    val dateAdded: Date = Date(),
    val createdAt: Date = Date(),
    val updatedAt: Date = Date(),

    // üîë CHAMPS DE PARTAGE
    val authorId: String,
    val authorName: String,
    val isShared: Boolean = true,
    val partnerIds: List<String> = emptyList()
) {

    companion object {
        fun fromFirestore(document: DocumentSnapshot): SharedFavoriteQuestion? {
            return try {
                val data = document.data ?: return null

                SharedFavoriteQuestion(
                    id = document.id,
                    questionId = data["questionId"] as? String ?: "",
                    questionText = data["questionText"] as? String ?: "",
                    categoryTitle = data["categoryTitle"] as? String ?: "",
                    emoji = data["emoji"] as? String ?: "",
                    dateAdded = (data["dateAdded"] as? Timestamp)?.toDate() ?: Date(),
                    createdAt = (data["createdAt"] as? Timestamp)?.toDate() ?: Date(),
                    updatedAt = (data["updatedAt"] as? Timestamp)?.toDate() ?: Date(),
                    authorId = data["authorId"] as? String ?: "",
                    authorName = data["authorName"] as? String ?: "",
                    isShared = data["isShared"] as? Boolean ?: true,
                    partnerIds = (data["partnerIds"] as? List<String>) ?: emptyList()
                )
            } catch (e: Exception) {
                Log.e("SharedFavoriteQuestion", "Erreur parsing Firestore: ${e.message}")
                null
            }
        }
    }

    fun toFirestore(): Map<String, Any> {
        return mapOf(
            "questionId" to questionId,
            "questionText" to questionText,
            "categoryTitle" to categoryTitle,
            "emoji" to emoji,
            "dateAdded" to Timestamp(dateAdded),
            "createdAt" to Timestamp(createdAt),
            "updatedAt" to Timestamp(updatedAt),
            "authorId" to authorId,
            "authorName" to authorName,
            "isShared" to isShared,
            "partnerIds" to partnerIds
        )
    }

    fun toLocalFavorite(): FavoriteQuestion {
        return FavoriteQuestion(
            id = id,
            questionId = questionId,
            questionText = questionText,
            categoryTitle = categoryTitle,
            emoji = emoji,
            dateAdded = dateAdded
        )
    }

    val formattedDateAdded: String
        get() {
            val formatter = SimpleDateFormat("dd MMM yyyy, HH:mm", Locale.getDefault())
            return formatter.format(dateAdded)
        }
}
```

### 8.3 Interface Android - FavoritesScreen Compose

```kotlin
@OptIn(ExperimentalFoundationApi::class)
@Composable
fun FavoritesScreen(
    viewModel: FavoritesViewModel = hiltViewModel(),
    onNavigateBack: () -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()
    val pagerState = rememberPagerState(pageCount = { uiState.favorites.size })

    LaunchedEffect(Unit) {
        viewModel.loadFavorites()
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                Brush.verticalGradient(
                    colors = listOf(
                        Color(0xFFF7F7F8),
                        Color(0xFFF2F2F5)
                    )
                )
            )
    ) {
        Column(
            modifier = Modifier.fillMaxSize()
        ) {
            // Header
            FavoritesHeader(
                onNavigateBack = onNavigateBack,
                onShowListView = { viewModel.showListView() }
            )

            Spacer(modifier = Modifier.height(40.dp))

            // Contenu principal
            if (uiState.favorites.isEmpty()) {
                EmptyFavoritesView(
                    modifier = Modifier
                        .fillMaxWidth()
                        .weight(1f)
                        .padding(horizontal = 20.dp)
                )
            } else {
                // üîë CARTES SWIPABLES AVEC PAGER
                HorizontalPager(
                    state = pagerState,
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(400.dp)
                        .padding(horizontal = 20.dp),
                    pageSpacing = 16.dp
                ) { page ->
                    val favorite = uiState.favorites[page]
                    val isCurrentPage = pagerState.currentPage == page

                    FavoriteQuestionCard(
                        favorite = favorite,
                        sharedFavorite = uiState.getSharedFavorite(favorite.questionId),
                        isActive = isCurrentPage,
                        onDelete = { viewModel.removeFavorite(favorite.questionId) },
                        modifier = Modifier.fillMaxSize()
                    )
                }

                Spacer(modifier = Modifier.height(20.dp))

                // Indicateurs de page
                if (uiState.favorites.isNotEmpty()) {
                    PageIndicator(
                        currentPage = pagerState.currentPage,
                        totalPages = uiState.favorites.size,
                        modifier = Modifier.align(Alignment.CenterHorizontally)
                    )
                }
            }

            Spacer(modifier = Modifier.height(40.dp))
        }

        // Loading overlay
        if (uiState.isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(Color.Black.copy(alpha = 0.3f)),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(
                    color = Color(0xFFFF4081)
                )
            }
        }

        // Messages d'erreur
        uiState.errorMessage?.let { error ->
            LaunchedEffect(error) {
                // Afficher Snackbar ou Toast
                // Puis nettoyer l'erreur
                viewModel.clearError()
            }
        }
    }
}

@Composable
fun FavoriteQuestionCard(
    favorite: FavoriteQuestion,
    sharedFavorite: SharedFavoriteQuestion?,
    isActive: Boolean,
    onDelete: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .scale(if (isActive) 1.0f else 0.95f)
            .alpha(if (isActive) 1.0f else 0.8f),
        shape = RoundedCornerShape(20.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)
    ) {
        Column(
            modifier = Modifier.fillMaxSize()
        ) {
            // üîë HEADER AVEC CAT√âGORIE
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(80.dp)
                    .background(
                        Brush.horizontalGradient(
                            colors = listOf(
                                Color(0xFFFF6B9D),
                                Color(0xFFFF8CC8)
                            )
                        )
                    ),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = favorite.categoryTitle,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Bold,
                    color = Color.White,
                    textAlign = TextAlign.Center
                )
            }

            // üîë CORPS AVEC QUESTION
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(
                        Brush.linearGradient(
                            colors = listOf(
                                Color(0xFFCC2952),
                                Color(0xFFE63C6B)
                            ),
                            start = Offset.Zero,
                            end = Offset.Infinite
                        )
                    ),
                contentAlignment = Alignment.Center
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.SpaceBetween,
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(30.dp)
                ) {
                    Spacer(modifier = Modifier.height(20.dp))

                    // Question
                    Text(
                        text = favorite.questionText,
                        fontSize = 22.sp,
                        fontWeight = FontWeight.Medium,
                        color = Color.White,
                        textAlign = TextAlign.Center,
                        lineHeight = 28.sp
                    )

                    Column {
                        // üîë INFORMATIONS D'AUTEUR
                        sharedFavorite?.let { shared ->
                            Row(
                                horizontalArrangement = Arrangement.Center,
                                verticalAlignment = Alignment.CenterVertically,
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                Icon(
                                    Icons.Filled.Favorite,
                                    contentDescription = null,
                                    tint = Color.White.copy(alpha = 0.8f),
                                    modifier = Modifier.size(16.dp)
                                )

                                Spacer(modifier = Modifier.width(8.dp))

                                Text(
                                    text = "Ajout√© par ${shared.authorName}",
                                    fontSize = 14.sp,
                                    fontWeight = FontWeight.Medium,
                                    color = Color.White.copy(alpha = 0.8f)
                                )

                                Spacer(modifier = Modifier.width(8.dp))

                                Text(
                                    text = "‚Ä¢",
                                    color = Color.White.copy(alpha = 0.6f)
                                )

                                Spacer(modifier = Modifier.width(8.dp))

                                Text(
                                    text = shared.formattedDateAdded,
                                    fontSize = 12.sp,
                                    color = Color.White.copy(alpha = 0.6f)
                                )
                            }

                            Spacer(modifier = Modifier.height(10.dp))
                        }

                        // Branding
                        Row(
                            horizontalArrangement = Arrangement.Center,
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            // Logo/Image si disponible
                            Text(
                                text = "Love2Love",
                                fontSize = 16.sp,
                                fontWeight = FontWeight.SemiBold,
                                color = Color.White.copy(alpha = 0.9f)
                            )
                        }
                    }
                }
            }
        }
    }
}
```

### 8.4 ViewModel Android

```kotlin
@HiltViewModel
class FavoritesViewModel @Inject constructor(
    private val favoritesRepository: FavoritesRepository,
    private val authRepository: AuthRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(FavoritesUiState())
    val uiState: StateFlow<FavoritesUiState> = _uiState

    data class FavoritesUiState(
        val favorites: List<FavoriteQuestion> = emptyList(),
        val sharedFavorites: List<SharedFavoriteQuestion> = emptyList(),
        val isLoading: Boolean = false,
        val errorMessage: String? = null
    ) {
        fun getSharedFavorite(questionId: String): SharedFavoriteQuestion? {
            return sharedFavorites.find { it.questionId == questionId }
        }
    }

    init {
        // Observer les favoris en temps r√©el
        viewModelScope.launch {
            combine(
                favoritesRepository.getAllFavorites(),
                favoritesRepository.sharedFavorites,
                favoritesRepository.isLoading
            ) { favorites, sharedFavorites, isLoading ->
                _uiState.value = _uiState.value.copy(
                    favorites = favorites,
                    sharedFavorites = sharedFavorites,
                    isLoading = isLoading
                )
            }.collect()
        }
    }

    fun loadFavorites() {
        viewModelScope.launch {
            try {
                val currentUser = authRepository.getCurrentUser()
                if (currentUser != null) {
                    favoritesRepository.initializeForUser(
                        userId = currentUser.uid,
                        userName = currentUser.displayName ?: "Utilisateur"
                    )
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    errorMessage = "Erreur lors du chargement: ${e.message}"
                )
            }
        }
    }

    fun addFavorite(question: Question, category: QuestionCategory) {
        viewModelScope.launch {
            try {
                val partnerId = authRepository.getCurrentUser()?.partnerId
                val result = favoritesRepository.addFavorite(question, category, partnerId)

                if (result.isFailure) {
                    _uiState.value = _uiState.value.copy(
                        errorMessage = result.exceptionOrNull()?.message ?: "Erreur lors de l'ajout"
                    )
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    errorMessage = "Erreur: ${e.message}"
                )
            }
        }
    }

    fun removeFavorite(questionId: String) {
        viewModelScope.launch {
            try {
                val currentUser = authRepository.getCurrentUser()
                if (currentUser != null) {
                    val result = favoritesRepository.removeFavorite(questionId, currentUser.uid)

                    if (result.isFailure) {
                        _uiState.value = _uiState.value.copy(
                            errorMessage = result.exceptionOrNull()?.message ?: "Erreur lors de la suppression"
                        )
                    }
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    errorMessage = "Erreur: ${e.message}"
                )
            }
        }
    }

    fun syncWithPartner() {
        viewModelScope.launch {
            try {
                val partnerId = authRepository.getCurrentUser()?.partnerId
                if (partnerId != null) {
                    val result = favoritesRepository.syncPartnerFavorites(partnerId)

                    if (result.isSuccess) {
                        val syncResult = result.getOrNull()
                        _uiState.value = _uiState.value.copy(
                            errorMessage = "Synchronisation r√©ussie: ${syncResult?.updatedFavoritesCount} favoris mis √† jour"
                        )
                    } else {
                        _uiState.value = _uiState.value.copy(
                            errorMessage = result.exceptionOrNull()?.message ?: "Erreur de synchronisation"
                        )
                    }
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    errorMessage = "Erreur: ${e.message}"
                )
            }
        }
    }

    fun showListView() {
        // Naviguer vers la vue liste
        // Navigation logic here
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(errorMessage = null)
    }
}
```

---

## üìã Conclusion

Le syst√®me de favoris partag√©s de CoupleApp iOS pr√©sente une architecture robuste et une synchronisation temps r√©el sophistiqu√©e :

### üéØ **Points Forts du Syst√®me :**

- **Partage automatique instantan√©** : Les favoris ajout√©s par un partenaire apparaissent imm√©diatement chez l'autre
- **Synchronisation bidirectionnelle** : Connexion partenaire ‚Üí Partage automatique de tous les favoris existants
- **Permissions granulaires** : Contr√¥le d'acc√®s auteur/partenaire pour lecture, modification, suppression
- **Interface temps r√©el** : Listeners Firestore avec mise √† jour automatique des vues
- **S√©curit√© multi-niveaux** : Firestore Rules + contr√¥les c√¥t√© client + audit logging

### üîß **Composants Techniques iOS :**

- `FavoritesService` - Service central avec listeners temps r√©el
- `SharedFavoriteQuestion` - Mod√®le avec partnerIds et m√©tadonn√©es d'auteur
- `FavoritesCardView` - Interface swipable avec informations de partage
- Cloud Function `syncPartnerFavorites()` - Synchronisation s√©curis√©e
- Firestore collection `favoriteQuestions` - Stockage avec arrayContains

### ü§ù **Logique de Partage Avanc√©e :**

- **partnerIds: [String]** : Array contenant les Firebase UIDs autoris√©s √† voir le favori
- **authorId: String** : Firebase UID de l'utilisateur qui a cr√©√© le favori
- **Ajout automatique** : Nouveau favori ‚Üí partnerIds inclut automatiquement le partenaire connect√©
- **Synchronisation connexion** : connectPartners() ‚Üí Mise √† jour de TOUS les favoris existants

### üî• **Firebase Integration Sophistiqu√©e :**

- **Listener temps r√©el** : `.whereField("partnerIds", arrayContains: currentUserId)`
- **Batch updates** : Synchronisation atomique de multiples favoris
- **Cloud Functions s√©curis√©es** : V√©rification connexion partenaire + validation permissions
- **Index optimis√©s** : Requ√™tes rapides sur partnerIds + authorId + dates

### üì± **Interface Utilisateur Immersive :**

- **Cartes swipables** : Navigation tactile entre favoris avec animations
- **M√©tadonn√©es partag√©es** : "Ajout√© par Marie ‚Ä¢ il y a 2 minutes"
- **Contr√¥les contextuels** : Suppression autoris√©e selon permissions
- **√âtats temps r√©el** : Loading, empty states, error handling

### ü§ñ **Adaptation Android Robuste :**

- **FavoritesRepository Kotlin** : StateFlow reactive + Coroutines async
- **Jetpack Compose moderne** : HorizontalPager pour swipe + animations fluides
- **Architecture MVVM** : ViewModel + Repository pattern clean
- **Firebase SDK Android** : Listeners temps r√©el + Cloud Functions identiques
- **Material Design 3** : Interface native Android avec th√®mes coh√©rents

### ‚ö° **Fonctionnalit√©s Uniques :**

- **Synchronisation √† la connexion** : Partenaires voient instantan√©ment TOUS les favoris historiques
- **Permissions bidirectionnelles** : Chaque partenaire peut supprimer les favoris de l'autre
- **Interface unifi√©e** : Mix transparent entre favoris propres et favoris partag√©s
- **Audit complet** : Logging s√©curis√© pour conformit√© et debug

### üìä **Performance et Scalabilit√© :**

- **Index Firestore optimis√©s** : Requ√™tes sub-100ms m√™me avec des milliers de favoris
- **Cache local Realm** : Favoris disponibles offline + sync intelligente
- **Batch operations** : Mise √† jour atomique de multiples documents
- **Listeners l√©gers** : Seules les modifications sont transmises

### ‚è±Ô∏è **Estimation D√©veloppement Android :**

- **Phase 1** : Repository + Mod√®les (2-3 semaines)
- **Phase 2** : Interface Compose + ViewModel (3-4 semaines)
- **Phase 3** : Synchronisation + Permissions (2-3 semaines)
- **Phase 4** : Tests + Optimisations (2-3 semaines)

**Total estim√© : 9-13 semaines** pour une r√©plication compl√®te du syst√®me iOS vers Android.

Ce syst√®me de favoris partag√©s repr√©sente un **avantage concurrentiel majeur** en cr√©ant un **engagement couple unique** o√π chaque interaction enrichit l'exp√©rience partag√©e, favorisant la **r√©tention long-terme** et l'**effet de r√©seau** dans la relation. üöÄ

L'architecture est **pr√™te pour l'√©volution** avec des fondations solides pour futures fonctionnalit√©s comme commentaires sur favoris, cat√©gories personnalis√©es partag√©es, ou recommandations bas√©es sur les favoris du partenaire.
