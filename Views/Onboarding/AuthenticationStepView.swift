import SwiftUI
import AuthenticationServices
import FirebaseAuth
import CryptoKit

struct AuthenticationStepView: View {
    @ObservedObject var viewModel: OnboardingViewModel
    @StateObject private var firebaseService = FirebaseService.shared
    @State private var currentNonce: String?
    
    var body: some View {
        VStack(spacing: 40) {
            // Titre
            VStack(spacing: 15) {
                Text("CR√âONS TON COMPTE !")
                    .font(.system(size: 28, weight: .bold))
                    .foregroundColor(.white)
                    .multilineTextAlignment(.center)
                
                Text("S√âCURISE TES DONN√âES")
                    .font(.system(size: 28, weight: .bold))
                    .foregroundColor(.white)
                    .multilineTextAlignment(.center)
            }
            .padding(.horizontal, 30)
            
            // Description
            Text("Cr√©e ton compte maintenant pour sauvegarder tes pr√©f√©rences et acc√©der √† toutes les fonctionnalit√©s premium !")
                .font(.system(size: 16))
                .foregroundColor(.white.opacity(0.9))
                .multilineTextAlignment(.center)
                .padding(.horizontal, 30)
            
            Spacer()
            
            // Ic√¥ne
            Text("üî•")
                .font(.system(size: 100))
            
            // Avantages de cr√©er un compte
            VStack(spacing: 15) {
                HStack(spacing: 15) {
                    Image(systemName: "icloud.fill")
                        .foregroundColor(.white)
                        .font(.system(size: 20))
                    Text("Sauvegarde automatique")
                        .font(.system(size: 16))
                        .foregroundColor(.white)
                    Spacer()
                }
                
                HStack(spacing: 15) {
                    Image(systemName: "devices")
                        .foregroundColor(.white)
                        .font(.system(size: 20))
                    Text("Synchronisation multi-appareils")
                        .font(.system(size: 16))
                        .foregroundColor(.white)
                    Spacer()
                }
                
                HStack(spacing: 15) {
                    Image(systemName: "heart.fill")
                        .foregroundColor(.white)
                        .font(.system(size: 20))
                    Text("Historique de tes conversations")
                        .font(.system(size: 16))
                        .foregroundColor(.white)
                    Spacer()
                }
            }
            .padding(.horizontal, 30)
            .padding()
            .background(Color.white.opacity(0.1))
            .cornerRadius(15)
            .padding(.horizontal, 30)
            
            Spacer()
            
            // Bouton Sign in with Apple
            SignInWithAppleButton(
                onRequest: { request in
                    print("üî• AuthenticationStepView: D√©but de la requ√™te Apple Sign In")
                    NSLog("üî•üî•üî• APPLE SIGN IN: DEBUT DE LA REQUETE")
                    
                    // G√©n√©rer le nonce
                    let nonce = randomNonceString()
                    currentNonce = nonce
                    request.nonce = sha256(nonce)
                    
                    print("üî• AuthenticationStepView: Bundle ID: \(Bundle.main.bundleIdentifier ?? "nil")")
                    print("üî• AuthenticationStepView: Nonce g√©n√©r√© et configur√©")
                    NSLog("üî•üî•üî• APPLE SIGN IN: BUNDLE ID: %@", Bundle.main.bundleIdentifier ?? "nil")
                    NSLog("üî•üî•üî• APPLE SIGN IN: NONCE GENERE")
                    
                    request.requestedScopes = [.fullName, .email]
                    print("üî• AuthenticationStepView: Scopes demand√©s: fullName, email")
                    NSLog("üî•üî•üî• APPLE SIGN IN: SCOPES DEMANDES")
                },
                onCompletion: { result in
                    print("üî• AuthenticationStepView: R√©ponse Apple Sign In re√ßue")
                    NSLog("üî•üî•üî• APPLE SIGN IN: REPONSE RECUE")
                    handleSignInWithApple(result)
                }
            )
            .signInWithAppleButtonStyle(.white)
            .frame(height: 56)
            .cornerRadius(28)
            .padding(.horizontal, 30)
            
            // Bouton Skip (pour le debug)
            Button("‚ö†Ô∏è SKIP AUTH (DEBUG)") {
                print("üî• AuthenticationStepView: Skip auth pour debug")
                NSLog("üî•üî•üî• APPLE SIGN IN: SKIP POUR DEBUG")
                viewModel.completeAuthentication()
            }
            .font(.system(size: 12))
            .foregroundColor(.white.opacity(0.7))
            .padding(.top, 20)
        }
        .onAppear {
            print("üî• AuthenticationStepView: Vue d'authentification apparue")
            NSLog("üî•üî•üî• AUTHENTICATION: VUE APPARUE")
            
            // V√©rifications de debug
            print("üî• AuthenticationStepView: Bundle ID: \(Bundle.main.bundleIdentifier ?? "nil")")
            NSLog("üî•üî•üî• AUTHENTICATION: BUNDLE ID: %@", Bundle.main.bundleIdentifier ?? "nil")
        }
    }
    
    private func handleSignInWithApple(_ result: Result<ASAuthorization, Error>) {
        switch result {
        case .success(let authorization):
            print("‚úÖ AuthenticationStepView: Authentification Apple r√©ussie")
            NSLog("üî•üî•üî• APPLE SIGN IN: SUCCES!")
            
            guard let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential else {
                print("‚ùå AuthenticationStepView: Credential Apple ID manquant")
                NSLog("‚ùå‚ùå‚ùå APPLE SIGN IN: CREDENTIAL MANQUANT")
                // Ne pas continuer si les credentials sont manquants
                return
            }
            
            guard let nonce = currentNonce else {
                print("‚ùå AuthenticationStepView: Nonce manquant")
                NSLog("‚ùå‚ùå‚ùå APPLE SIGN IN: NONCE MANQUANT")
                // Ne pas continuer si le nonce est manquant
                return
            }
            
            guard let appleIDToken = appleIDCredential.identityToken else {
                print("‚ùå AuthenticationStepView: Token Apple manquant")
                NSLog("‚ùå‚ùå‚ùå APPLE SIGN IN: TOKEN MANQUANT")
                // Ne pas continuer si le token est manquant
                return
            }
            
            guard let idTokenString = String(data: appleIDToken, encoding: .utf8) else {
                print("‚ùå AuthenticationStepView: Erreur de d√©codage du token")
                NSLog("‚ùå‚ùå‚ùå APPLE SIGN IN: ERREUR DECODAGE TOKEN")
                // Ne pas continuer si le d√©codage √©choue
                return
            }
            
            print("üî• AuthenticationStepView: Cr√©ation des credentials Firebase")
            NSLog("üî•üî•üî• APPLE SIGN IN: CREATION CREDENTIALS FIREBASE")
            
            let credential = OAuthProvider.credential(withProviderID: "apple.com",
                                                      idToken: idTokenString,
                                                      rawNonce: nonce)
            
            // Authentification Firebase
            Auth.auth().signIn(with: credential) { result, error in
                DispatchQueue.main.async {
                    if let error = error {
                        print("‚ùå AuthenticationStepView: Erreur Firebase: \(error.localizedDescription)")
                        NSLog("‚ùå‚ùå‚ùå FIREBASE AUTH: ERREUR: %@", error.localizedDescription)
                        // Ne pas continuer en cas d'erreur Firebase
                        return
                    }
                    
                    guard let firebaseUser = result?.user else {
                        print("‚ùå AuthenticationStepView: Utilisateur Firebase manquant")
                        NSLog("‚ùå‚ùå‚ùå FIREBASE AUTH: USER MANQUANT")
                        // Ne pas continuer si l'utilisateur Firebase est manquant
                        return
                    }
                    
                    print("‚úÖ AuthenticationStepView: Authentification Firebase r√©ussie!")
                    print("üî• AuthenticationStepView: Firebase UID: \(firebaseUser.uid)")
                    print("üî• AuthenticationStepView: Email: \(firebaseUser.email ?? "nil")")
                    NSLog("‚úÖ‚úÖ‚úÖ FIREBASE AUTH: SUCCES! UID: %@", firebaseUser.uid)
                    
                    // Cr√©er imm√©diatement un document utilisateur partiel avec les donn√©es d'onboarding
                    self.createPartialUserDocument(firebaseUser: firebaseUser)
                    
                    // Passer √† l'√©tape suivante (abonnement)
                    viewModel.completeAuthentication()
                }
            }
            
        case .failure(let error):
            print("‚ùå AuthenticationStepView: Erreur d'authentification Apple: \(error.localizedDescription)")
            NSLog("‚ùå‚ùå‚ùå APPLE SIGN IN: ERREUR: %@", error.localizedDescription)
            
            // Diagnostics suppl√©mentaires
            if let nsError = error as NSError? {
                print("‚ùå AuthenticationStepView: Code d'erreur: \(nsError.code)")
                print("‚ùå AuthenticationStepView: Domaine: \(nsError.domain)")
                NSLog("‚ùå‚ùå‚ùå APPLE SIGN IN: CODE ERREUR: %ld", nsError.code)
            }
            
            // V√©rifier si c'est une annulation par l'utilisateur
            if let authError = error as? ASAuthorizationError {
                switch authError.code {
                case .canceled:
                    print("üî• AuthenticationStepView: Authentification annul√©e par l'utilisateur - rester sur cette √©tape")
                    NSLog("üî• AuthenticationStepView: Authentification annul√©e par l'utilisateur")
                    // Ne pas appeler completeAuthentication() - rester sur l'√©tape d'authentification
                    return
                case .failed, .invalidResponse, .notHandled, .unknown:
                    print("üî• AuthenticationStepView: Erreur d'authentification - rester sur cette √©tape")
                    NSLog("üî• AuthenticationStepView: Erreur d'authentification")
                    // Ne pas appeler completeAuthentication() - rester sur l'√©tape d'authentification
                    return
                @unknown default:
                    print("üî• AuthenticationStepView: Erreur d'authentification inconnue - rester sur cette √©tape")
                    NSLog("üî• AuthenticationStepView: Erreur d'authentification inconnue")
                    // Ne pas appeler completeAuthentication() - rester sur l'√©tape d'authentification
                    return
                }
            }
            
            // Pour d'autres types d'erreurs, rester aussi sur cette √©tape
            print("üî• AuthenticationStepView: Erreur non-Apple - rester sur cette √©tape")
            NSLog("üî• AuthenticationStepView: Erreur non-Apple")
            // Ne pas appeler completeAuthentication() - l'utilisateur peut r√©essayer
        }
    }
    
    // MARK: - Nonce Generation
    
    private func randomNonceString(length: Int = 32) -> String {
        precondition(length > 0)
        let charset: [Character] =
        Array("0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._")
        var result = ""
        var remainingLength = length
        
        while remainingLength > 0 {
            let randoms: [UInt8] = (0 ..< 16).map { _ in
                var random: UInt8 = 0
                let errorCode = SecRandomCopyBytes(kSecRandomDefault, 1, &random)
                if errorCode != errSecSuccess {
                    fatalError("Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \(errorCode)")
                }
                return random
            }
            
            randoms.forEach { random in
                if remainingLength == 0 {
                    return
                }
                
                if random < charset.count {
                    result.append(charset[Int(random)])
                    remainingLength -= 1
                }
            }
        }
        
        return result
    }
    
    private func sha256(_ input: String) -> String {
        let inputData = Data(input.utf8)
        let hashedData = SHA256.hash(data: inputData)
        let hashString = hashedData.compactMap {
            String(format: "%02x", $0)
        }.joined()
        
        return hashString
    }
    
    private func createPartialUserDocument(firebaseUser: FirebaseAuth.User) {
        print("üî• AuthenticationStepView: Cr√©ation d'un document utilisateur partiel")
        print("üî•üî•üî• AUTH PARTIAL: CREATION DOCUMENT PARTIEL PENDANT ONBOARDING")
        NSLog("üî• AuthenticationStepView: Cr√©ation d'un document utilisateur partiel")
        
        // NOUVEAU: Marquer le d√©but du processus d'onboarding pour √©viter les redirections
        FirebaseService.shared.startOnboardingProcess()
        
        // Cr√©er un utilisateur avec les donn√©es d'onboarding collect√©es
        let partialUser = User(
            name: viewModel.userName,
            birthDate: viewModel.birthDate,
            relationshipGoals: viewModel.selectedGoals,
            relationshipDuration: viewModel.relationshipDuration,
            partnerCode: viewModel.partnerCode.isEmpty ? nil : viewModel.partnerCode,
            isSubscribed: false, // Sera mis √† jour apr√®s l'abonnement
            onboardingInProgress: true // IMPORTANT: Marquer l'onboarding comme en cours
        )
        
        print("üî• AuthenticationStepView: Sauvegarde des donn√©es partielles pour: \(partialUser.name)")
        print("üî•üî•üî• AUTH PARTIAL: SAUVEGARDE PARTIELLE POUR: \(partialUser.name)")
        NSLog("üî• AuthenticationStepView: Sauvegarde des donn√©es partielles pour: \(partialUser.name)")
        
        // IMPORTANT: Utiliser savePartialUserData pour marquer l'onboarding comme en cours
        FirebaseService.shared.savePartialUserData(partialUser)
    }
} 