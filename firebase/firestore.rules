rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Utilisateurs peuvent acc√©der √† leurs propres donn√©es compl√®tes
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Permettre la lecture des donn√©es du partenaire connect√© (HYBRIDE - TOUS LES CHAMPS)
      allow read: if request.auth != null && 
                     isConnectedPartnerHybrid(request.auth.uid, userId);
    }
    
    // Collection s√©par√©e pour les donn√©es partag√©es entre partenaires
    match /sharedPartnerData/{userId} {
      // L'utilisateur peut √©crire ses propres donn√©es partag√©es
      allow write: if request.auth != null && request.auth.uid == userId;
      
      // Les partenaires connect√©s peuvent lire ces donn√©es partag√©es
      allow read: if request.auth != null && 
                     (request.auth.uid == userId || 
                      isConnectedPartnerHybrid(request.auth.uid, userId));
    }
    
    // R√®gles pour les codes partenaires
    match /partnerCodes/{codeId} {
      // Permettre la lecture pour v√©rifier l'existence et la validit√© d'un code
      allow read: if request.auth != null;
      
      // Permettre la cr√©ation seulement par le propri√©taire du code
      allow create: if request.auth != null && 
                   request.auth.uid == request.resource.data.userId;
      
      // Permettre la mise √† jour dans ces cas :
      // 1. Le propri√©taire du code peut toujours modifier son code
      // 2. Un utilisateur peut se connecter √† un code libre (connectedPartnerId == null)
      // 3. Le partenaire connect√© peut modifier certains champs
      allow update: if request.auth != null && 
                   (
                     // Cas 1: Propri√©taire du code
                     request.auth.uid == resource.data.userId ||
                     
                     // Cas 2: Connexion √† un code libre
                     (resource.data.connectedPartnerId == null && 
                      request.resource.data.connectedPartnerId == request.auth.uid) ||
                     
                     // Cas 3: Partenaire d√©j√† connect√© modifie ses donn√©es
                     (request.auth.uid == resource.data.connectedPartnerId)
                   );
      
      // Permettre la suppression seulement par le propri√©taire
      allow delete: if request.auth != null && 
                   request.auth.uid == resource.data.userId;
    }
    
    // R√®gles pour les entr√©es de journal partag√©
    match /journalEntries/{entryId} {
      // Lecture : utilisateur authentifi√© ET (auteur OU dans partnerIds)
      allow read: if request.auth != null && 
                     (request.auth.uid == resource.data.authorId ||
                      (resource.data.partnerIds != null && 
                       request.auth.uid in resource.data.partnerIds));
      
      // Cr√©ation : utilisateur authentifi√© ET auteur ET dans partnerIds
      allow create: if request.auth != null && 
                       request.auth.uid == request.resource.data.authorId &&
                       request.resource.data.partnerIds != null &&
                       request.auth.uid in request.resource.data.partnerIds;
      
      // Modification : seulement l'auteur peut modifier
      allow update: if request.auth != null && 
                       request.auth.uid == resource.data.authorId;
      
      // Suppression : seulement l'auteur peut supprimer
      allow delete: if request.auth != null && 
                       request.auth.uid == resource.data.authorId;
    }
    
    // üÜï NOUVEAU: R√®gles pour les favoris partag√©s (m√™me pattern que journalEntries)
    match /favoriteQuestions/{favoriteId} {
      // Lecture : utilisateur authentifi√© ET (auteur OU dans partnerIds)
      allow read: if request.auth != null && 
                     (request.auth.uid == resource.data.authorId ||
                      (resource.data.partnerIds != null && 
                       request.auth.uid in resource.data.partnerIds));
      
      // üîß CORRECTION: Permettre les queries/listes pour les utilisateurs authentifi√©s
      allow list: if request.auth != null;
      
      // üõ°Ô∏è CR√âATION SIMPLIFI√âE : utilisateur authentifi√© ET dans partnerIds
      allow create: if request.auth != null && 
                       request.resource.data.partnerIds != null &&
                       request.auth.uid in request.resource.data.partnerIds &&
                       // V√©rifier que l'auteur est bien celui qui cr√©√©
                       request.auth.uid == request.resource.data.authorId;
      
      // Modification : seulement l'auteur peut modifier
      allow update: if request.auth != null && 
                       request.auth.uid == resource.data.authorId;
      
      // Suppression : l'auteur OU n'importe qui dans partnerIds peut supprimer
      allow delete: if request.auth != null && 
                       (request.auth.uid == resource.data.authorId ||
                        (resource.data.partnerIds != null && 
                         request.auth.uid in resource.data.partnerIds));
    }
    
    // R√®gles pour les logs de partage d'abonnement (conformit√© Apple)
    match /subscription_sharing_logs/{logId} {
      // Permettre la cr√©ation pour tous les utilisateurs authentifi√©s (pour les logs)
      allow create: if request.auth != null;
      // Lecture seulement pour les administrateurs (pas impl√©ment√© ici)
      allow read: if false;
    }
    
    // üÜï NOUVEAU: R√®gles pour les questions quotidiennes partag√©es
    match /dailyQuestions/{questionId} {
      // Lecture : utilisateur authentifi√© ET fait partie du couple (son ID est dans coupleId)
      allow read: if request.auth != null && 
                     userIsInCouple(request.auth.uid, resource.data.coupleId);
      
      // Cr√©ation : utilisateur authentifi√© ET fait partie du couple ET les partenaires sont connect√©s
      allow create: if request.auth != null && 
                       userIsInCouple(request.auth.uid, request.resource.data.coupleId) &&
                       partnersAreConnectedForCouple(request.resource.data.coupleId);
      
      // Modification : utilisateur authentifi√© ET fait partie du couple
      allow update: if request.auth != null && 
                       userIsInCouple(request.auth.uid, resource.data.coupleId);
      
      // Suppression : utilisateur authentifi√© ET fait partie du couple
      allow delete: if request.auth != null && 
                       userIsInCouple(request.auth.uid, resource.data.coupleId);
      
      // NOUVEAU: R√®gles pour les sous-collections responses
      match /responses/{responseId} {
        allow read, write: if request.auth != null && 
          request.auth.uid in get(/databases/$(database)/documents/dailyQuestions/$(questionId)).data.coupleId.split('_');
      }
    }
    
    // üÜï NOUVEAU: R√®gles pour les param√®tres des questions quotidiennes
    match /dailyQuestionSettings/{coupleId} {
      // Lecture : utilisateur authentifi√© ET fait partie du couple (son ID est dans coupleId)
      allow read: if request.auth != null && 
                     userIsInCouple(request.auth.uid, coupleId);
      
      // üîß CORRECTION: Cr√©ation simplifi√©e - v√©rifier seulement que l'utilisateur fait partie du couple
      allow create: if request.auth != null && 
                       userIsInCouple(request.auth.uid, request.resource.data.coupleId);
      
      // Modification : utilisateur authentifi√© ET fait partie du couple
      allow update: if request.auth != null && 
                       userIsInCouple(request.auth.uid, resource.data.coupleId);
      
      // Suppression : utilisateur authentifi√© ET fait partie du couple
      allow delete: if request.auth != null && 
                       userIsInCouple(request.auth.uid, resource.data.coupleId);
    }
    
    // R√®gles pour les signalements de contenu inappropri√©
    match /content_reports/{reportId} {
      // Cr√©ation : utilisateur authentifi√© peut cr√©er un signalement
      allow create: if request.auth != null;
      
      // Lecture : seulement pour les administrateurs (ou l'auteur du signalement)
      allow read: if request.auth != null && request.auth.uid == resource.data.reporterUserId;
      
      // Modification : seulement pour les administrateurs (pas impl√©ment√© ici)
      allow update: if false;
      
      // Suppression : interdite
      allow delete: if false;
    }
    
    // R√®gles pour les statistiques de mod√©ration
    match /user_moderation_stats/{userId} {
      // Lecture : utilisateur peut voir ses propres stats
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // √âcriture : seulement via Cloud Functions
      allow write: if false;
    }
    
    // R√®gles pour les alertes administrateur
    match /admin_alerts/{alertId} {
      // Lecture/√©criture : seulement pour les administrateurs (pas impl√©ment√© ici)
      allow read, write: if false;
    }
    
    // Interdire tout autre acc√®s
    match /{document=**} {
      allow read, write: if false;
    }
  }
  
  // üîß FONCTION HYBRIDE ULTRA-ROBUSTE - V√âRIFIE TOUS LES CHAMPS POSSIBLES
  function isConnectedPartnerHybrid(currentUserId, targetUserId) {
    let currentUserDoc = get(/databases/$(database)/documents/users/$(currentUserId));
    let targetUserDoc = get(/databases/$(database)/documents/users/$(targetUserId));
    
    return (
      // M√âTHODE 1: V√©rification bidirectionnelle classique avec partnerId
      (
        ('partnerId' in currentUserDoc.data && 'partnerId' in targetUserDoc.data) &&
        (currentUserDoc.data.partnerId == targetUserId && 
         targetUserDoc.data.partnerId == currentUserId)
      ) ||
      
      // M√âTHODE 2: V√©rification avec connectedPartnerId (ancienne m√©thode)
      (
        ('connectedPartnerId' in currentUserDoc.data && 'connectedPartnerId' in targetUserDoc.data) &&
        (currentUserDoc.data.connectedPartnerId == targetUserId && 
         targetUserDoc.data.connectedPartnerId == currentUserId)
      ) ||
      
      // M√âTHODE 3: V√©rification crois√©e (partnerId vers connectedPartnerId)
      (
        ('partnerId' in currentUserDoc.data && 'connectedPartnerId' in targetUserDoc.data) &&
        (currentUserDoc.data.partnerId == targetUserId && 
         targetUserDoc.data.connectedPartnerId == currentUserId)
      ) ||
      
      // M√âTHODE 4: V√©rification crois√©e inverse (connectedPartnerId vers partnerId)
      (
        ('connectedPartnerId' in currentUserDoc.data && 'partnerId' in targetUserDoc.data) &&
        (currentUserDoc.data.connectedPartnerId == targetUserId && 
         targetUserDoc.data.partnerId == currentUserId)
      )
    );
  }
  
  // üÜï NOUVELLES FONCTIONS HELPER POUR LES QUESTIONS QUOTIDIENNES
  
  // V√©rifie si un utilisateur fait partie d'un couple bas√© sur le coupleId
  function userIsInCouple(userId, coupleId) {
    // Le coupleId est au format "userId1_userId2" (tri√© alphab√©tiquement)
    let userIds = coupleId.split('_');
    
    // V√©rifier que l'userId correspond √† un des deux utilisateurs du couple
    return userIds.size() == 2 && 
           (userId == userIds[0] || userId == userIds[1]);
  }
  
  // V√©rifie que les deux partenaires du couple sont bien connect√©s entre eux
  function partnersAreConnectedForCouple(coupleId) {
    let userIds = coupleId.split('_');
    
    // V√©rifier qu'on a exactement 2 utilisateurs
    return userIds.size() == 2 && 
           isConnectedPartnerHybrid(userIds[0], userIds[1]);
  }
} 